/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub type __uint8_t = ::std::os::raw::c_uchar;
    pub type __uint16_t = ::std::os::raw::c_ushort;
    pub type __int32_t = ::std::os::raw::c_int;
    pub type __uint32_t = ::std::os::raw::c_uint;
    pub type __uint64_t = ::std::os::raw::c_ulong;
    pub type size_t = ::std::os::raw::c_ulong;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub const TalkingState_INVALID: root::TalkingState = -1;
    pub const TalkingState_PASSIVE: root::TalkingState = 0;
    pub const TalkingState_TALKING: root::TalkingState = 1;
    pub const TalkingState_WHISPERING: root::TalkingState = 2;
    pub const TalkingState_SHOUTING: root::TalkingState = 3;
    #[doc = " This enum's values represent talking states a user can be in when using Mumble."]
    pub type TalkingState = i32;
    pub const TransmissionMode_TM_CONTINOUS: root::TransmissionMode = 0;
    pub const TransmissionMode_TM_VOICE_ACTIVATION: root::TransmissionMode = 1;
    pub const TransmissionMode_TM_PUSH_TO_TALK: root::TransmissionMode = 2;
    #[doc = " This enum's values represent transmission modes a user might have configured. Transmission mode"]
    #[doc = " in this context is referring to a method that determines when a user is speaking and thus when"]
    #[doc = " to transmit audio packets."]
    pub type TransmissionMode = u32;
    pub const ErrorCode_EC_GENERIC_ERROR: root::ErrorCode = -1;
    pub const ErrorCode_EC_OK: root::ErrorCode = 0;
    pub const ErrorCode_EC_POINTER_NOT_FOUND: root::ErrorCode = 1;
    pub const ErrorCode_EC_NO_ACTIVE_CONNECTION: root::ErrorCode = 2;
    pub const ErrorCode_EC_USER_NOT_FOUND: root::ErrorCode = 3;
    pub const ErrorCode_EC_CHANNEL_NOT_FOUND: root::ErrorCode = 4;
    pub const ErrorCode_EC_CONNECTION_NOT_FOUND: root::ErrorCode = 5;
    pub const ErrorCode_EC_UNKNOWN_TRANSMISSION_MODE: root::ErrorCode = 6;
    pub const ErrorCode_EC_AUDIO_NOT_AVAILABLE: root::ErrorCode = 7;
    pub const ErrorCode_EC_INVALID_SAMPLE: root::ErrorCode = 8;
    pub const ErrorCode_EC_INVALID_PLUGIN_ID: root::ErrorCode = 9;
    pub const ErrorCode_EC_INVALID_MUTE_TARGET: root::ErrorCode = 10;
    pub const ErrorCode_EC_CONNECTION_UNSYNCHRONIZED: root::ErrorCode = 11;
    pub const ErrorCode_EC_INVALID_API_VERSION: root::ErrorCode = 12;
    #[doc = " This enum's values represent the error codes that are being used by the MumbleAPI."]
    #[doc = " You can get a string-representation for each error code via the errorMessage function."]
    pub type ErrorCode = i32;
    #[doc = " A struct for representing a version of the form major.minor.patch"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Version {
        pub major: i32,
        pub minor: i32,
        pub patch: i32,
    }
    #[test]
    fn bindgen_test_layout_Version() {
        assert_eq!(
            ::std::mem::size_of::<Version>(),
            12usize,
            concat!("Size of: ", stringify!(Version))
        );
        assert_eq!(
            ::std::mem::align_of::<Version>(),
            4usize,
            concat!("Alignment of ", stringify!(Version))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Version>())).major as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Version),
                "::",
                stringify!(major)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Version>())).minor as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Version),
                "::",
                stringify!(minor)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Version>())).patch as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Version),
                "::",
                stringify!(patch)
            )
        );
    }
    #[doc = " Typedef for the type of a talking state"]
    pub use self::super::root::TalkingState as talking_state_t;
    #[doc = " Typedef for the type of a transmission mode"]
    pub use self::super::root::TransmissionMode as transmission_mode_t;
    #[doc = " Typedef for the type of a version"]
    pub type version_t = root::Version;
    #[doc = " Typedef for the type of a connection"]
    pub type mumble_connection_t = i32;
    #[doc = " Typedef for the type of a user"]
    pub type mumble_userid_t = u32;
    #[doc = " Typedef for the type of a channel"]
    pub type mumble_channelid_t = i32;
    #[doc = " Typedef for the type of an error (code)"]
    pub use self::super::root::ErrorCode as mumble_error_t;
    #[doc = " Typedef for the type of a plugin ID"]
    pub type plugin_id_t = u32;
    extern "C" {
        #[link_name = "\u{1}_ZL25MUMBLE_PLUGIN_API_VERSION"]
        pub static MUMBLE_PLUGIN_API_VERSION: root::version_t;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct MumbleAPI {
        #[doc = " Frees the given pointer."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param pointer The pointer to free"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub freeMemory: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                pointer: *mut ::std::os::raw::c_void,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Gets the connection ID of the server the user is currently active on (the user's audio output is directed at)."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param[out] connection A pointer to the memory location the ID should be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then it is valid to access the"]
        #[doc = " \tvalue of the provided pointer"]
        pub getActiveServerConnection: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: *mut root::mumble_connection_t,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Checks whether the given connection has finished initializing yet."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param[out] A pointer to the boolean variable that'll hold the info whether the server has finished synchronization yet"]
        #[doc = " \tafter this function has executed successfully."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub isConnectionSynchronized: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                synchronized: *mut bool,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Fills in the information about the local user."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param[out] userID A pointer to the memory the user's ID shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getLocalUserID: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: *mut root::mumble_userid_t,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Fills in the information about the given user's name."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The user's ID whose name should be obtained"]
        #[doc = " @param[out] userName A pointer to where the pointer to the allocated string (C-encoded) should be written to. The"]
        #[doc = " \tallocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " \tallocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getUserName: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: root::mumble_userid_t,
                userName: *mut *mut ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Fills in the information about the given channel's name."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param channelID The channel's ID whose name should be obtained"]
        #[doc = " @param[out] channelName A pointer to where the pointer to the allocated string (C-ecoded) should be written to. The"]
        #[doc = " \tallocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " \tallocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getChannelName: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                channelID: root::mumble_channelid_t,
                channelName: *mut *mut ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Gets an array of all users that are currently connected to the provided server. Passing a nullptr as any of the out-parameter"]
        #[doc = " will prevent that property to be set/allocated. If you are only interested in the user count you can thus pass nullptr as the"]
        #[doc = " users parameter and save time on allocating + freeing the channels-array while still getting the size out."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param[out] users A pointer to where the pointer of the allocated array shall be written. The"]
        #[doc = " \tallocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " \tallocated if this function returns STATUS_OK."]
        #[doc = " @param[out] userCount A pointer to where the size of the allocated user-array shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getAllUsers: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                users: *mut *mut root::mumble_userid_t,
                userCount: *mut root::size_t,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Gets an array of all channels on the provided server. Passing a nullptr as any of the out-parameter will prevent"]
        #[doc = " that property to be set/allocated. If you are only interested in the channel count you can thus pass nullptr as the"]
        #[doc = " channels parameter and save time on allocating + freeing the channels-array while still getting the size out."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param[out] channels A pointer to where the pointer of the allocated array shall be written. The"]
        #[doc = " \tallocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " \tallocated if this function returns STATUS_OK."]
        #[doc = " @param[out] channelCount A pointer to where the size of the allocated channel-array shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getAllChannels: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                channels: *mut *mut root::mumble_channelid_t,
                channelCount: *mut root::size_t,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Gets the ID of the channel the given user is currently connected to."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user to search for"]
        #[doc = " @param[out] A pointer to where the ID of the channel shall be written"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getChannelOfUser: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: root::mumble_userid_t,
                channel: *mut root::mumble_channelid_t,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Gets an array of all users in the specified channel."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param channelID The ID of the channel whose users shall be retrieved"]
        #[doc = " @param[out] userList A pointer to where the pointer of the allocated array shall be written. The allocated memory has"]
        #[doc = " \tto be freed by a call to freeMemory by the plugin eventually. The memory will only be allocated if this function"]
        #[doc = " \treturns STATUS_OK."]
        #[doc = " @param[out] userCount A pointer to where the size of the allocated user-array shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getUsersInChannel: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                channelID: root::mumble_channelid_t,
                userList: *mut *mut root::mumble_userid_t,
                userCount: *mut root::size_t,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Gets the current transmission mode of the local user."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param[out] transmissionMode A pointer to where the transmission mode shall be written."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getLocalUserTransmissionMode: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                transmissionMode: *mut root::transmission_mode_t,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Checks whether the given user is currently locally muted."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user to search for"]
        #[doc = " @param[out] A pointer to where the local mute state of that user shall be written"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub isUserLocallyMuted: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: root::mumble_userid_t,
                muted: *mut bool,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Requests Mumble to set the local user's transmission mode to the specified one. If you only need to temporarily set"]
        #[doc = " the transmission mode to continous, use requestMicrophoneActivationOverwrite instead as this saves you the work of"]
        #[doc = " restoring the previous state afterwards."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param transmissionMode The requested transmission mode"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestLocalUserTransmissionMode: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                transmissionMode: root::transmission_mode_t,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Requests Mumble to move the given user into the given channel"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user that shall be moved"]
        #[doc = " @param channelID The ID of the channel to move the user to"]
        #[doc = " @param password The password of the target channel (UTF-8 encoded as a C-string). Pass NULL if the target channel does not require a"]
        #[doc = " \tpassword for entering"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestUserMove: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: root::mumble_userid_t,
                channelID: root::mumble_channelid_t,
                password: *const ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Requests Mumble to overwrite the microphone activation so that the microphone is always on (same as if the user had chosen"]
        #[doc = " the continous transmission mode). If a plugin requests this overwrite, it is responsible for deactivating the overwrite again"]
        #[doc = " once it is no longer required"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param activate Whether to activate the overwrite (false deactivates an existing overwrite)"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestMicrophoneActivationOvewrite: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                activate: bool,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Requests Mumble to set the local mute state of the given client. Note that this only affects the **local** mute state"]
        #[doc = " opposed to a server-mute (client is globally muted by the server) or the client's own mute-state (client has muted its"]
        #[doc = " microphone and thus isn't transmitting any audio)."]
        #[doc = " Furthermore it must be noted that muting the local user with this function does not work (it doesn't make sense). If"]
        #[doc = " you try to do so, this function will fail. In order to make this work, this function will also fail if the server"]
        #[doc = " has not finished synchronizing with the client yet."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function."]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user that shall be moved"]
        #[doc = " @param muted Whether to locally mute the given client (opposed to unmuting it)"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestLocalMute: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: root::mumble_userid_t,
                muted: bool,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Fills in the information about a user with the specified name, if such a user exists. The search is case-sensitive."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userName The respective user's name"]
        #[doc = " @param[out] userID A pointer to the memory the user's ID shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer may"]
        #[doc = " \tbe accessed."]
        pub findUserByName: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userName: *const ::std::os::raw::c_char,
                userID: *mut root::mumble_userid_t,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Fills in the information about a channel with the specified name, if such a channel exists. The search is case-sensitive."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param channelName The respective channel's name"]
        #[doc = " @param[out] channelID A pointer to the memory the channel's ID shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer may"]
        #[doc = " \tbe accessed."]
        pub findChannelByName: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                channelName: *const ::std::os::raw::c_char,
                channelID: *mut root::mumble_channelid_t,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Sends the provided data to the provided client(s). This kind of data can only be received by another plugin active"]
        #[doc = " on that client. The sent data can be seen by any active plugin on the receiving client. Therefore the sent data"]
        #[doc = " must not contain sensitive information or anything else that shouldn't be known by others."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to send the data through (the server the given users are on)"]
        #[doc = " @param users An array of user IDs to send the data to"]
        #[doc = " @param userCount The size of the provided user-array"]
        #[doc = " @param data The data that shall be sent as a String"]
        #[doc = " @param dataLength The length of the data-string"]
        #[doc = " @param dataID The ID of the sent data. This has to be used by the receiving plugin(s) to figure out what to do with"]
        #[doc = " \tthe data"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub sendData: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                users: *mut root::mumble_userid_t,
                userCount: root::size_t,
                data: *const ::std::os::raw::c_char,
                dataLength: root::size_t,
                dataID: *const ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Logs the given message (typically to Mumble's console). All passed strings have to be UTF-8 encoded."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param message The message to log"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub log: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                message: *const ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        >,
        #[doc = " Plays the provided sample. It uses libsndfile as a backend so the respective file format needs to be supported by it"]
        #[doc = " in order for this to work out (see http://www.mega-nerd.com/libsndfile/)."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param samplePath The path to the sample that shall be played (UTF-8 encoded)"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub playSample: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                samplePath: *const ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        >,
    }
    #[test]
    fn bindgen_test_layout_MumbleAPI() {
        assert_eq!(
            ::std::mem::size_of::<MumbleAPI>(),
            168usize,
            concat!("Size of: ", stringify!(MumbleAPI))
        );
        assert_eq!(
            ::std::mem::align_of::<MumbleAPI>(),
            8usize,
            concat!("Alignment of ", stringify!(MumbleAPI))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).freeMemory as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(freeMemory)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).getActiveServerConnection as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getActiveServerConnection)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).isConnectionSynchronized as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(isConnectionSynchronized)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getLocalUserID as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getLocalUserID)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getUserName as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getUserName)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getChannelName as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getChannelName)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getAllUsers as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getAllUsers)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getAllChannels as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getAllChannels)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getChannelOfUser as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getChannelOfUser)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getUsersInChannel as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getUsersInChannel)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).getLocalUserTransmissionMode as *const _
                    as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getLocalUserTransmissionMode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).isUserLocallyMuted as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(isUserLocallyMuted)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).requestLocalUserTransmissionMode as *const _
                    as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestLocalUserTransmissionMode)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).requestUserMove as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestUserMove)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).requestMicrophoneActivationOvewrite
                    as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestMicrophoneActivationOvewrite)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).requestLocalMute as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestLocalMute)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).findUserByName as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(findUserByName)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).findChannelByName as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(findChannelByName)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).sendData as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(sendData)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).log as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(log)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).playSample as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(playSample)
            )
        );
    }
    extern "C" {
        #[doc = " Gets called right after loading the plugin in order to let the plugin initialize."]
        #[doc = ""]
        #[doc = " Registers the ID of this plugin."]
        #[doc = " @param id The ID for this plugin. This is the ID Mumble will reference this plugin with"]
        #[doc = " \tand by which this plugin can identify itself when communicating with Mumble."]
        #[doc = " @returns The status of the initialization. If everything went fine, return STATUS_OK"]
        pub fn mumble_init(id: u32) -> root::mumble_error_t;
    }
    extern "C" {
        #[doc = " Gets called when unloading the plugin in order to allow it to clean up after itself."]
        pub fn mumble_shutdown();
    }
    extern "C" {
        #[doc = " Gets the name of the plugin. The plugin has to guarantee that the returned pointer will still be valid. The string will be copied"]
        #[doc = " for further usage though."]
        #[doc = ""]
        #[doc = " @returns A pointer to the plugin name (encoded as a C-String)"]
        pub fn mumble_getName() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Gets the Version of the plugin-API this plugin intends to use."]
        #[doc = " Mumble will decide whether this plugin is loadable or not based on the return value of this function."]
        #[doc = ""]
        #[doc = " @return The respective API Version"]
        pub fn mumble_getAPIVersion() -> root::version_t;
    }
    extern "C" {
        #[doc = " Provides the MumbleAPI struct to the plugin. This struct contains function pointers that can be used"]
        #[doc = " to interact with the Mumble client. It is up to the plugin to store this struct somewhere if it wants to make use"]
        #[doc = " of it at some point."]
        #[doc = ""]
        #[doc = " @param api The MumbleAPI struct"]
        pub fn mumble_registerAPIFunctions(api: root::MumbleAPI);
    }
    extern "C" {
        #[doc = " Tells the plugin some basic information about the Mumble client loading it."]
        #[doc = " This function will be the first one that is being called on this plugin - even before it is decided whether to load"]
        #[doc = " the plugin at all."]
        #[doc = ""]
        #[doc = " @param mumbleVersion The Version of the Mumble client"]
        #[doc = " @param mumbleAPIVersion The Version of the plugin-API the Mumble client runs with"]
        #[doc = " @param minimalExpectedAPIVersion The minimal Version the Mumble clients expects this plugin to meet in order to load it"]
        pub fn mumble_setMumbleInfo(
            mumbleVersion: root::version_t,
            mumbleAPIVersion: root::version_t,
            minimalExpectedAPIVersion: root::version_t,
        );
    }
    extern "C" {
        #[doc = " Gets the Version of this plugin"]
        #[doc = ""]
        #[doc = " @returns The plugin's version"]
        pub fn mumble_getVersion() -> root::version_t;
    }
    extern "C" {
        #[doc = " Gets the name of the plugin author(s). The plugin has to guarantee that the returned pointer will still be valid. The string will"]
        #[doc = " be copied for further usage though."]
        #[doc = ""]
        #[doc = " @returns A pointer to the author(s) name(s) (encoded as a C-String)"]
        pub fn mumble_getAuthor() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Gets the description of the plugin. The plugin has to guarantee that the returned pointer will still be valid. The string will"]
        #[doc = " be copied for further usage though."]
        #[doc = ""]
        #[doc = " @returns A pointer to the description (encoded as a C-String)"]
        pub fn mumble_getDescription() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Gets the feature set of this plugin. The feature set is described by bitwise or'ing the elements of the PluginFeature enum"]
        #[doc = " together."]
        #[doc = ""]
        #[doc = " @returns The feature set of this plugin"]
        pub fn mumble_getFeatures() -> u32;
    }
    extern "C" {
        #[doc = " Requests this plugin to deactivate the given (sub)set of provided features."]
        #[doc = " If this is not possible, the features that can't be deactivated shall be returned by this function."]
        #[doc = ""]
        #[doc = " Example (check if FEATURE_POSITIONAL shall be deactivated):"]
        #[doc = " @code"]
        #[doc = " if (features & FEATURE_POSITIONAL) {"]
        #[doc = " \t// positional shall be deactivated"]
        #[doc = " };"]
        #[doc = " @endcode"]
        #[doc = ""]
        #[doc = " @param features The feature set that shall be deactivated"]
        #[doc = " @returns The feature set that can't be disabled (bitwise or'ed). If all requested features can be disabled, return"]
        #[doc = " \tFEATURE_NONE. If none of the requested features can be disabled return the unmodified features parameter."]
        pub fn mumble_deactivateFeatures(features: u32) -> u32;
    }
    extern "C" {
        #[doc = " Indicates that Mumble wants to use this plugin to request positional data. Therefore it should check whether it is currently"]
        #[doc = " able to do so and allocate memory that is needed for that process."]
        #[doc = " As a parameter this function gets an array of names and an array of PIDs. They are of same length and the PID at index i"]
        #[doc = " belongs to a program whose name is listed at index i in the \"name-array\"."]
        #[doc = ""]
        #[doc = " @param programNames An array of pointers to the program names"]
        #[doc = " @param programPIDs An array of the corresponding program PIDs"]
        #[doc = " @param programCount The length of programNames and programPIDs"]
        #[doc = " @returns The error code. If everything went fine PDEC_OK shall be returned. In that case Mumble will start frequently"]
        #[doc = " \tcalling fetchPositionalData. If this returns anything but PDEC_OK, Mumble will assume that the plugin is (currently)"]
        #[doc = " \tuncapable of providing positional data. In this case this function must not have allocated any memory that needs to be"]
        #[doc = " \tcleaned up later on. Depending on the returned error code, Mumble might try to call this function again later on."]
        pub fn mumble_initPositionalData(
            programNames: *mut *const ::std::os::raw::c_char,
            programPIDs: *const u64,
            programCount: root::size_t,
        ) -> u8;
    }
    extern "C" {
        #[doc = " Retrieves the positional audio data. If no data can be fetched, set all float-vectors to 0 and return false."]
        #[doc = ""]
        #[doc = " @param[out] avatarPos A float-array of size 3 representing the cartesian position of the player/avatar in the ingame world."]
        #[doc = " \tOne unit represents one meter of distance."]
        #[doc = " @param[out] avatarDir A float-array of size 3 representing the cartesian direction-vector of the player/avatar ingame (where it"]
        #[doc = " \tis facing)."]
        #[doc = " @param[out] avatarAxis A float-array of size 3 representing the vector pointing from the toes of the character to its head. One"]
        #[doc = " \tunit represents one meter of distance."]
        #[doc = " @param[out] cameraPos A float-array of size 3 representing the cartesian position of the camera in the ingame world."]
        #[doc = " \tOne unit represents one meter of distance."]
        #[doc = " @param[out] cameraDir A float-array of size 3 representing the cartesian direction-vector of the camera ingame (where it"]
        #[doc = " \tis facing)."]
        #[doc = " @param[out] cameraAxis A float-array of size 3 representing a vector from the bottom of the camera to its top. One unit"]
        #[doc = " \trepresents one meter of distance."]
        #[doc = " @param[out] context A pointer to where the pointer to a C-encoded string storing the context of the provided positional data"]
        #[doc = " \tshall be written. This context should include information about the server (and team) the player is on. Only players with identical"]
        #[doc = " \tcontext will be able to hear each other's audio. The returned pointer has to remain valid until the next invokation of this function"]
        #[doc = " \tor until shutdownPositionalData is called."]
        #[doc = " @param[out] identity A pointer to where the pointer to a C-encoded string storing the identity of the player shall be written. It can"]
        #[doc = " \tbe polled by external scripts from the server and should uniquely identify the player in the game. The pointer has to remain valid"]
        #[doc = " \tuntil the next invokation of this function or until shutdownPositionalData is called."]
        #[doc = " @returns Whether this plugin can continue delivering positional data. If this function returns false, shutdownPositionalData will"]
        #[doc = " \tbe called."]
        pub fn mumble_fetchPositionalData(
            avatarPos: *mut f32,
            avatarDir: *mut f32,
            avatarAxis: *mut f32,
            cameraPos: *mut f32,
            cameraDir: *mut f32,
            cameraAxis: *mut f32,
            context: *mut *const ::std::os::raw::c_char,
            identity: *mut *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Indicates that this plugin will not be asked for positional data any longer. Thus any memory allocated for this purpose should"]
        #[doc = " be freed at this point."]
        pub fn mumble_shutdownPositionalData();
    }
    extern "C" {
        #[doc = " Called when connecting to a server."]
        #[doc = ""]
        #[doc = " @param connection The ID of the newly established server-connection"]
        pub fn mumble_onServerConnected(connection: root::mumble_connection_t);
    }
    extern "C" {
        #[doc = " Called when disconnecting from a server."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection that has been terminated"]
        pub fn mumble_onServerDisconnected(connection: root::mumble_connection_t);
    }
    extern "C" {
        #[doc = " Called when the client has finished synchronizing with the server"]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection that has been terminated"]
        pub fn mumble_onServerSynchronized(connection: root::mumble_connection_t);
    }
    extern "C" {
        #[doc = " Called whenever any user on the server enters a channel"]
        #[doc = " This function will also be called when freshly connecting to a server as each user on that"]
        #[doc = " server needs to be \"added\" to the respective channel as far as the local client is concerned."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection this event is connected to"]
        #[doc = " @param userID The ID of the user this event has been triggered for"]
        #[doc = " @param previousChannelID The ID of the chanel the user is coming from. Negative IDs indicate that there is no previous channel (e.g. the user"]
        #[doc = " \tfreshly connected to the server) or the channel isn't available because of any other reason."]
        #[doc = " @param newChannelID The ID of the channel the user has entered. If the ID is negative, the new channel could not be retrieved. This means"]
        #[doc = " \tthat the ID is invalid."]
        pub fn mumble_onChannelEntered(
            connection: root::mumble_connection_t,
            userID: root::mumble_userid_t,
            previousChannelID: root::mumble_channelid_t,
            newChannelID: root::mumble_channelid_t,
        );
    }
    extern "C" {
        #[doc = " Called whenever a user leaves a channel."]
        #[doc = " This includes a client disconnecting from the server as this will also lead to the user not being in that channel anymore."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection this event is connected to"]
        #[doc = " @param userID The ID of the user that left the channel"]
        #[doc = " @param channelID The ID of the channel the user left. If the ID is negative, the channel could not be retrieved. This means that the ID is"]
        #[doc = " \tinvalid."]
        pub fn mumble_onChannelExited(
            connection: root::mumble_connection_t,
            userID: root::mumble_userid_t,
            channelID: root::mumble_channelid_t,
        );
    }
    extern "C" {
        #[doc = " Called when any user changes his/her talking state."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection this event is connected to"]
        #[doc = " @param userID The ID of the user whose talking state has been changed"]
        #[doc = " @param talkingState The new TalkingState the user has switched to."]
        pub fn mumble_onUserTalkingStateChanged(
            connection: root::mumble_connection_t,
            userID: root::mumble_userid_t,
            talkingState: root::talking_state_t,
        );
    }
    extern "C" {
        #[doc = " Called whenever there is audio input."]
        #[doc = ""]
        #[doc = " @param inputPCM A pointer to a short-array holding the pulse-code-modulation (PCM) representing the audio input. Its length"]
        #[doc = " \tis sampleCount * channelCount."]
        #[doc = " @param sampleCount The amount of sample points per channel"]
        #[doc = " @param channelCount The amount of channels in the audio"]
        #[doc = " @param isSpeech A boolean flag indicating whether Mumble considers the input as part of speech (instead of background noise)"]
        #[doc = " @returns Whether this callback has modified the audio input-array"]
        pub fn mumble_onAudioInput(
            inputPCM: *mut ::std::os::raw::c_short,
            sampleCount: u32,
            channelCount: u16,
            isSpeech: bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Called whenever Mumble fetches data from an active audio source (could be a voice packet or a playing sample)."]
        #[doc = " The provided audio buffer is the raw buffer without any processing applied to it yet."]
        #[doc = ""]
        #[doc = " @param outputPCM A pointer to a float-array holding the pulse-code-modulation (PCM) representing the audio output. Its length"]
        #[doc = " \tis sampleCount * channelCount."]
        #[doc = " @param sampleCount The amount of sample points per channel"]
        #[doc = " @param channelCount The amount of channels in the audio"]
        #[doc = " @param isSpeech Whether this audio belongs to a received voice packet (and will thus (most likely) contain speech)"]
        #[doc = " @param userID If isSpeech is true, this contains the ID of the user this voice packet belongs to. If isSpeech is false,"]
        #[doc = " \tthe content of this parameter is unspecified and should not be accessed"]
        #[doc = " @returns Whether this callback has modified the audio output-array"]
        pub fn mumble_onAudioSourceFetched(
            outputPCM: *mut f32,
            sampleCount: u32,
            channelCount: u16,
            isSpeech: bool,
            userID: root::mumble_userid_t,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Called whenever the fully mixed and processed audio is about to be handed to the audio backend (about to be played)."]
        #[doc = " Note that this happens immediately before Mumble clips the audio buffer."]
        #[doc = ""]
        #[doc = " @param outputPCM A pointer to a float-array holding the pulse-code-modulation (PCM) representing the audio output. Its length"]
        #[doc = " \tis sampleCount * channelCount."]
        #[doc = " @param sampleCount The amount of sample points per channel"]
        #[doc = " @param channelCount The amount of channels in the audio"]
        #[doc = " @returns Whether this callback has modified the audio output-array"]
        pub fn mumble_onAudioOutputAboutToPlay(
            outputPCM: *mut f32,
            sampleCount: u32,
            channelCount: u16,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Called whenever data has been received that has been sent by a plugin. This data should only be processed by the"]
        #[doc = " intended plugin. For this reason a dataID is provided that should be used to determine whether the data is intended"]
        #[doc = " for this plugin or not. As soon as the data has been processed, no further plugins will be notified about it."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection the data is coming from"]
        #[doc = " @param sender The ID of the user whose client's plugin has sent the data"]
        #[doc = " @param data The sent data represented as a string"]
        #[doc = " @param dataLength The length of data"]
        #[doc = " @param dataID The ID of this data"]
        #[doc = " @return Whether the given data has been processed by this plugin"]
        pub fn mumble_onReceiveData(
            connection: root::mumble_connection_t,
            sender: root::mumble_userid_t,
            data: *const ::std::os::raw::c_char,
            dataLength: root::size_t,
            dataID: *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Called when a new user gets added to the user model. This is the case when that new user freshly connects to the server the"]
        #[doc = " local user is on but also when the local user connects to a server other clients are already connected to (in this case this"]
        #[doc = " method will be called for every client already on that server)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param userID The ID of the user that has been added"]
        pub fn mumble_onUserAdded(
            connection: root::mumble_connection_t,
            userID: root::mumble_userid_t,
        );
    }
    extern "C" {
        #[doc = " Called when a user gets removed from the user model. This is the case when that user disconnects from the server the"]
        #[doc = " local user is on but also when the local user disconnects from a server other clients are connected to (in this case this"]
        #[doc = " method will be called for every client on that server)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param userID The ID of the user that has been removed"]
        pub fn mumble_onUserRemoved(
            connection: root::mumble_connection_t,
            userID: root::mumble_userid_t,
        );
    }
    extern "C" {
        #[doc = " Called when a new channel gets added to the user model. This is the case when a new channel is created on the server the local"]
        #[doc = " user is on but also when the local user connects to a server that contains channels other than the root-channel (in this case"]
        #[doc = " this method will be called for ever non-root channel on that server)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param channelID The ID of the channel that has been added"]
        pub fn mumble_onChannelAdded(
            connection: root::mumble_connection_t,
            channelID: root::mumble_channelid_t,
        );
    }
    extern "C" {
        #[doc = " Called when a channel gets removed from the user model. This is the case when a channel is removed on the server the local"]
        #[doc = " user is on but also when the local user disconnects from a server that contains channels other than the root-channel (in this case"]
        #[doc = " this method will be called for ever non-root channel on that server)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param channelID The ID of the channel that has been removed"]
        pub fn mumble_onChannelRemoved(
            connection: root::mumble_connection_t,
            channelID: root::mumble_channelid_t,
        );
    }
    extern "C" {
        #[doc = " Called when a channel gets renamed. This also applies when a new channel is created (thus assigning it an initial name is also"]
        #[doc = " considered renaming)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param channelID The ID of the channel that has been renamed"]
        pub fn mumble_onChannelRenamed(
            connection: root::mumble_connection_t,
            channelID: root::mumble_channelid_t,
        );
    }
    extern "C" {
        #[doc = " Called when a key has been pressed or released while Mumble has keyboard focus."]
        #[doc = " Note that this callback will only work if the user has explicitly given permission to monitor keyboard"]
        #[doc = " events for this plugin. Thus if you want to use this callback, make sure your users know that they have to"]
        #[doc = " enable that."]
        #[doc = ""]
        #[doc = " @param keyCode The key code of the respective key. The character codes are defined"]
        #[doc = " \tvia the KeyCode enum. For printable 7-bit ASCII characters these codes conform"]
        #[doc = " \tto the ASCII code-page with the only difference that case is not distinguished. Therefore"]
        #[doc = " \talways the upper-case letter code will be used for letters."]
        #[doc = " @param wasPres Whether the respective key has been pressed (instead of released)"]
        pub fn mumble_onKeyEvent(keyCode: u32, wasPress: bool);
    }
    extern "C" {
        #[doc = " This function is used to determine whether the plugin can find an update for itself that is available for download."]
        #[doc = ""]
        #[doc = " NOTE: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " @return Whether the plugin was able to find an update for itself"]
        pub fn mumble_hasUpdate() -> bool;
    }
    extern "C" {
        #[doc = " This function is used to retrieve the URL for downloading the newer/updated version of this plugin."]
        #[doc = " If the URL is too long for the provided buffer, it will have to be split up and be read chunk by chunk. Make sure"]
        #[doc = " though that you don't forget about the trailing null byte."]
        #[doc = ""]
        #[doc = " NOTE: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " @param buffer A pointer to the char buffer to write the UTF-8 encoded URL (as C-string) into"]
        #[doc = " @param bufferSize The size of the buffer"]
        #[doc = " @param offset The offset in the URL from which this functions should start writing it to the buffer"]
        #[doc = " @param Whether the URL has been completely written into the buffer yet. If this is false, this function will be called"]
        #[doc = " \tagain with a modified offset until the URL has been completely transferred."]
        pub fn mumble_getUpdateDownloadURL(
            buffer: *mut ::std::os::raw::c_char,
            bufferSize: u16,
            offset: u16,
        ) -> bool;
    }
}
