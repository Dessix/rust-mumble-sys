/* automatically generated by rust-bindgen 0.57.0 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod m {
    #[allow(unused_imports)]
    use self::super::m;
    #[repr(i32)]
    #[doc = " This enum's values represent talking states a user can be in when using Mumble."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum TalkingState {
        INVALID = -1,
        PASSIVE = 0,
        TALKING = 1,
        WHISPERING = 2,
        SHOUTING = 3,
        TALKING_MUTED = 4,
    }
    #[repr(i32)]
    #[doc = " This enum's values represent transmission modes a user might have configured. Transmission mode"]
    #[doc = " in this context is referring to a method that determines when a user is speaking and thus when"]
    #[doc = " to transmit audio packets."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum TransmissionMode {
        TM_CONTINOUS = 0,
        TM_VOICE_ACTIVATION = 1,
        TM_PUSH_TO_TALK = 2,
    }
    #[repr(i32)]
    #[doc = " This enum's values represent the error codes that are being used by the MumbleAPI."]
    #[doc = " You can get a string-representation for each error code via the errorMessage function."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum ErrorCode {
        EC_INTERNAL_ERROR = -2,
        EC_GENERIC_ERROR = -1,
        EC_OK = 0,
        EC_POINTER_NOT_FOUND = 1,
        EC_NO_ACTIVE_CONNECTION = 2,
        EC_USER_NOT_FOUND = 3,
        EC_CHANNEL_NOT_FOUND = 4,
        EC_CONNECTION_NOT_FOUND = 5,
        EC_UNKNOWN_TRANSMISSION_MODE = 6,
        EC_AUDIO_NOT_AVAILABLE = 7,
        EC_INVALID_SAMPLE = 8,
        EC_INVALID_PLUGIN_ID = 9,
        EC_INVALID_MUTE_TARGET = 10,
        EC_CONNECTION_UNSYNCHRONIZED = 11,
        EC_INVALID_API_VERSION = 12,
        EC_UNSYNCHRONIZED_BLOB = 13,
        EC_UNKNOWN_SETTINGS_KEY = 14,
        EC_WRONG_SETTINGS_TYPE = 15,
        EC_SETTING_WAS_REMOVED = 16,
        EC_DATA_TOO_BIG = 17,
        EC_DATA_ID_TOO_LONG = 18,
        EC_API_REQUEST_TIMEOUT = 19,
        EC_OPERATION_UNSUPPORTED_BY_SERVER = 20,
    }
    #[repr(i32)]
    #[doc = " This enum's values represent keys for specific settings inside Mumble."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum SettingsKey {
        MSK_INVALID = -1,
        MSK_AUDIO_INPUT_VOICE_HOLD = 0,
        MSK_AUDIO_INPUT_VAD_SILENCE_THRESHOLD = 1,
        MSK_AUDIO_INPUT_VAD_SPEECH_THRESHOLD = 2,
        MSK_AUDIO_OUTPUT_PA_MINIMUM_DISTANCE = 3,
        MSK_AUDIO_OUTPUT_PA_MAXIMUM_DISTANCE = 4,
        MSK_AUDIO_OUTPUT_PA_BLOOM = 5,
        MSK_AUDIO_OUTPUT_PA_MINIMUM_VOLUME = 6,
    }
    #[doc = " A struct for representing a version of the form major.minor.patch"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct Version {
        pub major: i32,
        pub minor: i32,
        pub patch: i32,
    }
    #[test]
    fn bindgen_test_layout_Version() {
        assert_eq!(
            ::std::mem::size_of::<Version>(),
            12usize,
            concat!("Size of: ", stringify!(Version))
        );
        assert_eq!(
            ::std::mem::align_of::<Version>(),
            4usize,
            concat!("Alignment of ", stringify!(Version))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Version>())).major as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Version),
                "::",
                stringify!(major)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Version>())).minor as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Version),
                "::",
                stringify!(minor)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Version>())).patch as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Version),
                "::",
                stringify!(patch)
            )
        );
    }
    #[doc = " This struct is used to return Strings from a plugin to Mumble. It is needed in order to"]
    #[doc = " work around the limitation of std::string not being part of C (it holds important information"]
    #[doc = " about the String's lifetime management requirements)."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct MumbleStringWrapper {
        #[doc = " The pointer to the actual String data"]
        pub data: *const ::std::os::raw::c_char,
        #[doc = " The size of the pointed String data"]
        pub size: usize,
        #[doc = " Whether the wrapped String needs to be released"]
        #[doc = " after its usage. Instances for which this would be"]
        #[doc = " false: Static Strings, String literals"]
        pub needsReleasing: bool,
    }
    #[test]
    fn bindgen_test_layout_MumbleStringWrapper() {
        assert_eq!(
            ::std::mem::size_of::<MumbleStringWrapper>(),
            12usize,
            concat!("Size of: ", stringify!(MumbleStringWrapper))
        );
        assert_eq!(
            ::std::mem::align_of::<MumbleStringWrapper>(),
            4usize,
            concat!("Alignment of ", stringify!(MumbleStringWrapper))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleStringWrapper>())).data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleStringWrapper),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleStringWrapper>())).size as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleStringWrapper),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleStringWrapper>())).needsReleasing as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleStringWrapper),
                "::",
                stringify!(needsReleasing)
            )
        );
    }
    #[doc = " Typedef for the type of a talking state"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct TalkingStateT(pub m::TalkingState);
    impl ::std::ops::Deref for TalkingStateT {
        type Target = m::TalkingState;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for TalkingStateT {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of a transmission mode"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct TransmissionModeT(pub m::TransmissionMode);
    impl ::std::ops::Deref for TransmissionModeT {
        type Target = m::TransmissionMode;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for TransmissionModeT {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of a version"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct VersionT(pub m::Version);
    impl ::std::ops::Deref for VersionT {
        type Target = m::Version;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for VersionT {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of a connection"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct ConnectionT(pub i32);
    impl ::std::ops::Deref for ConnectionT {
        type Target = i32;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for ConnectionT {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of a user"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct UserIdT(pub u32);
    impl ::std::ops::Deref for UserIdT {
        type Target = u32;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for UserIdT {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of a channel"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct ChannelIdT(pub i32);
    impl ::std::ops::Deref for ChannelIdT {
        type Target = i32;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for ChannelIdT {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of an error (code)"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct ErrorT(pub m::ErrorCode);
    impl ::std::ops::Deref for ErrorT {
        type Target = m::ErrorCode;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for ErrorT {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of a plugin ID"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct PluginId(pub u32);
    impl ::std::ops::Deref for PluginId {
        type Target = u32;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for PluginId {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of a key to a setting in Mumble"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct SettingsKeyT(pub m::SettingsKey);
    impl ::std::ops::Deref for SettingsKeyT {
        type Target = m::SettingsKey;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for SettingsKeyT {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    extern "C" {
        #[link_name = "\u{1}_MUMBLE_PLUGIN_API_VERSION"]
        pub static mumble_plugin_api_version: m::VersionT;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct MumbleAPI {
        #[doc = " Frees the given pointer."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param pointer The pointer to free"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub freeMemory: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                pointer: *const ::std::os::raw::c_void,
            ) -> m::ErrorT,
        >,
        #[doc = " Gets the connection ID of the server the user is currently active on (the user's audio output is directed at)."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param[out] connection A pointer to the memory location the ID should be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then it is valid to access"]
        #[doc = " the value of the provided pointer"]
        pub getActiveServerConnection: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: *mut m::ConnectionT,
            ) -> m::ErrorT,
        >,
        #[doc = " Checks whether the given connection has finished initializing yet."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param[out] A pointer to the boolean variable that'll hold the info whether the server has finished"]
        #[doc = " synchronization yet after this function has executed successfully."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub isConnectionSynchronized: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                synchronized: *mut bool,
            ) -> m::ErrorT,
        >,
        #[doc = " Fills in the information about the local user."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param[out] userID A pointer to the memory the user's ID shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub getLocalUserID: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                userID: *mut m::UserIdT,
            ) -> m::ErrorT,
        >,
        #[doc = " Fills in the information about the given user's name."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The user's ID whose name should be obtained"]
        #[doc = " @param[out] userName A pointer to where the pointer to the allocated string (C-encoded) should be written to."]
        #[doc = " The allocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " allocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub getUserName: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                userID: m::UserIdT,
                userName: *mut *const ::std::os::raw::c_char,
            ) -> m::ErrorT,
        >,
        #[doc = " Fills in the information about the given channel's name."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param channelID The channel's ID whose name should be obtained"]
        #[doc = " @param[out] channelName A pointer to where the pointer to the allocated string (C-ecoded) should be written to."]
        #[doc = " The allocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " allocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub getChannelName: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                channelID: m::ChannelIdT,
                channelName: *mut *const ::std::os::raw::c_char,
            ) -> m::ErrorT,
        >,
        #[doc = " Gets an array of all users that are currently connected to the provided server. Passing a nullptr as any of the"]
        #[doc = " out-parameter will prevent that property to be set/allocated. If you are only interested in the user count you"]
        #[doc = " can thus pass nullptr as the users parameter and save time on allocating + freeing the channels-array while"]
        #[doc = " still getting the size out."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param[out] users A pointer to where the pointer of the allocated array shall be written. The"]
        #[doc = " allocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " allocated if this function returns STATUS_OK."]
        #[doc = " @param[out] userCount A pointer to where the size of the allocated user-array shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub getAllUsers: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                users: *mut *mut m::UserIdT,
                userCount: *mut usize,
            ) -> m::ErrorT,
        >,
        #[doc = " Gets an array of all channels on the provided server. Passing a nullptr as any of the out-parameter will prevent"]
        #[doc = " that property to be set/allocated. If you are only interested in the channel count you can thus pass nullptr as"]
        #[doc = " the channels parameter and save time on allocating + freeing the channels-array while still getting the size"]
        #[doc = " out."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param[out] channels A pointer to where the pointer of the allocated array shall be written. The"]
        #[doc = " allocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " allocated if this function returns STATUS_OK."]
        #[doc = " @param[out] channelCount A pointer to where the size of the allocated channel-array shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub getAllChannels: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                channels: *mut *mut m::ChannelIdT,
                channelCount: *mut usize,
            ) -> m::ErrorT,
        >,
        #[doc = " Gets the ID of the channel the given user is currently connected to."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user to search for"]
        #[doc = " @param[out] A pointer to where the ID of the channel shall be written"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub getChannelOfUser: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                userID: m::UserIdT,
                channel: *mut m::ChannelIdT,
            ) -> m::ErrorT,
        >,
        #[doc = " Gets an array of all users in the specified channel."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param channelID The ID of the channel whose users shall be retrieved"]
        #[doc = " @param[out] userList A pointer to where the pointer of the allocated array shall be written. The allocated"]
        #[doc = " memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be allocated if"]
        #[doc = " this function returns STATUS_OK."]
        #[doc = " @param[out] userCount A pointer to where the size of the allocated user-array shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub getUsersInChannel: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                channelID: m::ChannelIdT,
                userList: *mut *mut m::UserIdT,
                userCount: *mut usize,
            ) -> m::ErrorT,
        >,
        #[doc = " Gets the current transmission mode of the local user."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param[out] transmissionMode A pointer to where the transmission mode shall be written."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub getLocalUserTransmissionMode: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                transmissionMode: *mut m::TransmissionModeT,
            ) -> m::ErrorT,
        >,
        #[doc = " Checks whether the given user is currently locally muted."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user to check for"]
        #[doc = " @param[out] muted A pointer to where the local mute state of that user shall be written"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub isUserLocallyMuted: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                userID: m::UserIdT,
                muted: *mut bool,
            ) -> m::ErrorT,
        >,
        #[doc = " Checks whether the local user is currently muted."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param[out] muted A pointer to where the mute state of the local user shall be written"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub isLocalUserMuted: ::std::option::Option<
            unsafe extern "C" fn(callerID: m::PluginId, muted: *mut bool) -> m::ErrorT,
        >,
        #[doc = " Checks whether the local user is currently deafened."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param[out] deafened A pointer to where the deaf state of the local user shall be written"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub isLocalUserDeafened: ::std::option::Option<
            unsafe extern "C" fn(callerID: m::PluginId, deafened: *mut bool) -> m::ErrorT,
        >,
        #[doc = " Gets the hash of the given user (can be used to recognize users between restarts)"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user to search for"]
        #[doc = " @param[out] hash A pointer to where the pointer to the allocated string (C-encoded) should be written to. The"]
        #[doc = " allocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " allocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub getUserHash: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                userID: m::UserIdT,
                hash: *mut *const ::std::os::raw::c_char,
            ) -> m::ErrorT,
        >,
        #[doc = " Gets the hash of the server for the given connection (can be used to recognize servers between restarts)"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection"]
        #[doc = " @param[out] hash A pointer to where the pointer to the allocated string (C-encoded) should be written to. The"]
        #[doc = " allocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " allocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub getServerHash: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                hash: *mut *const ::std::os::raw::c_char,
            ) -> m::ErrorT,
        >,
        #[doc = " Gets the comment of the given user. Note that a user might have a comment configured that hasn't been"]
        #[doc = " synchronized to this client yet. In this case this function will return EC_UNSYNCHRONIZED_BLOB. As of now there"]
        #[doc = " is now way to request the synchronization to happen via the Plugin-API."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection"]
        #[doc = " @param userID the ID of the user whose comment should be obtained"]
        #[doc = " @param[out] comment A pointer to where the pointer to the allocated string (C-encoded) should be written to. The"]
        #[doc = " allocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " allocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub getUserComment: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                userID: m::UserIdT,
                comment: *mut *const ::std::os::raw::c_char,
            ) -> m::ErrorT,
        >,
        #[doc = " Gets the description of the given channel. Note that a channel might have a description configured that hasn't"]
        #[doc = " been synchronized to this client yet. In this case this function will return EC_UNSYNCHRONIZED_BLOB. As of now"]
        #[doc = " there is now way to request the synchronization to happen via the Plugin-API."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection"]
        #[doc = " @param channelID the ID of the channel whose comment should be obtained"]
        #[doc = " @param[out] description A pointer to where the pointer to the allocated string (C-encoded) should be written to."]
        #[doc = " The allocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " allocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub getChannelDescription: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                channelID: m::ChannelIdT,
                description: *mut *const ::std::os::raw::c_char,
            ) -> m::ErrorT,
        >,
        #[doc = " Requests Mumble to set the local user's transmission mode to the specified one. If you only need to temporarily"]
        #[doc = " set the transmission mode to continous, use requestMicrophoneActivationOverwrite instead as this saves you the"]
        #[doc = " work of restoring the previous state afterwards."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param transmissionMode The requested transmission mode"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestLocalUserTransmissionMode: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                transmissionMode: m::TransmissionModeT,
            ) -> m::ErrorT,
        >,
        #[doc = " Requests Mumble to move the given user into the given channel"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user that shall be moved"]
        #[doc = " @param channelID The ID of the channel to move the user to"]
        #[doc = " @param password The password of the target channel (UTF-8 encoded as a C-string). Pass NULL if the target"]
        #[doc = " channel does not require a password for entering"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestUserMove: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                userID: m::UserIdT,
                channelID: m::ChannelIdT,
                password: *const ::std::os::raw::c_char,
            ) -> m::ErrorT,
        >,
        #[doc = " Requests Mumble to overwrite the microphone activation so that the microphone is always on (same as if the user"]
        #[doc = " had chosen the continous transmission mode). If a plugin requests this overwrite, it is responsible for"]
        #[doc = " deactivating the overwrite again once it is no longer required"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param activate Whether to activate the overwrite (false deactivates an existing overwrite)"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestMicrophoneActivationOvewrite: ::std::option::Option<
            unsafe extern "C" fn(callerID: m::PluginId, activate: bool) -> m::ErrorT,
        >,
        #[doc = " Requests Mumble to set the local mute state of the given client. Note that this only affects the **local** mute"]
        #[doc = " state opposed to a server-mute (client is globally muted by the server) or the client's own mute-state (client"]
        #[doc = " has muted its microphone and thus isn't transmitting any audio). Furthermore it must be noted that muting the"]
        #[doc = " local user with this function does not work (it doesn't make sense). If you try to do so, this function will"]
        #[doc = " fail. In order to make this work, this function will also fail if the server has not finished synchronizing with"]
        #[doc = " the client yet. For muting the local user, use requestLocalUserMute instead."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function."]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user that shall be muted"]
        #[doc = " @param muted Whether to locally mute the given client (opposed to unmuting it)"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestLocalMute: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                userID: m::UserIdT,
                muted: bool,
            ) -> m::ErrorT,
        >,
        #[doc = " Requests Mumble to set the mute state of the local user. In the UI this is referred to as \"self-mute\"."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function."]
        #[doc = " @param muted Whether to locally mute the local user (opposed to unmuting it)"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestLocalUserMute: ::std::option::Option<
            unsafe extern "C" fn(callerID: m::PluginId, muted: bool) -> m::ErrorT,
        >,
        #[doc = " Requests Mumble to set the deaf state of the local user. In the UI this is referred to as \"self-deaf\"."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function."]
        #[doc = " @param deafened Whether to locally deafen the local user (opposed to undeafening it)"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestLocalUserDeaf: ::std::option::Option<
            unsafe extern "C" fn(callerID: m::PluginId, deafened: bool) -> m::ErrorT,
        >,
        #[doc = " Sets the comment of the local user"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection"]
        #[doc = " @param comment The new comment to use (C-encoded). A subset of HTML formatting is supported."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " may be accessed"]
        pub requestSetLocalUserComment: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                comment: *const ::std::os::raw::c_char,
            ) -> m::ErrorT,
        >,
        #[doc = " Fills in the information about a user with the specified name, if such a user exists. The search is"]
        #[doc = " case-sensitive."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userName The respective user's name"]
        #[doc = " @param[out] userID A pointer to the memory the user's ID shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer may"]
        #[doc = " be accessed."]
        pub findUserByName: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                userName: *const ::std::os::raw::c_char,
                userID: *mut m::UserIdT,
            ) -> m::ErrorT,
        >,
        #[doc = " Fills in the information about a channel with the specified name, if such a channel exists. The search is"]
        #[doc = " case-sensitive."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param channelName The respective channel's name"]
        #[doc = " @param[out] channelID A pointer to the memory the channel's ID shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer may"]
        #[doc = " be accessed."]
        pub findChannelByName: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                channelName: *const ::std::os::raw::c_char,
                channelID: *mut m::ChannelIdT,
            ) -> m::ErrorT,
        >,
        #[doc = " Fills in the current value of the setting with the given key. Note that this function can only be used for"]
        #[doc = " settings whose value is a bool!"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param key The key to the desired setting"]
        #[doc = " @param[out] outValue A pointer to the memory the setting's value shall be written to."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer may"]
        #[doc = " be accessed."]
        pub getMumbleSetting_bool: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                key: m::SettingsKeyT,
                outValue: *mut bool,
            ) -> m::ErrorT,
        >,
        #[doc = " Fills in the current value of the setting with the given key. Note that this function can only be used for"]
        #[doc = " settings whose value is an int!"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param key The key to the desired setting"]
        #[doc = " @param[out] outValue A pointer to the memory the setting's value shall be written to."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer may"]
        #[doc = " be accessed."]
        pub getMumbleSetting_int: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                key: m::SettingsKeyT,
                outValue: *mut i64,
            ) -> m::ErrorT,
        >,
        #[doc = " Fills in the current value of the setting with the given key. Note that this function can only be used for"]
        #[doc = " settings whose value is a double!"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param key The key to the desired setting"]
        #[doc = " @param[out] outValue A pointer to the memory the setting's value shall be written to."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer may"]
        #[doc = " be accessed."]
        pub getMumbleSetting_double: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                key: m::SettingsKeyT,
                outValue: *mut f64,
            ) -> m::ErrorT,
        >,
        #[doc = " Fills in the current value of the setting with the given key. Note that this function can only be used for"]
        #[doc = " settings whose value is a String!"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param key The key to the desired setting"]
        #[doc = " @param[out] outValue The memory address to which the pointer to the setting's value (the String) will be"]
        #[doc = " written. The allocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will"]
        #[doc = " only be allocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer may"]
        #[doc = " be accessed."]
        pub getMumbleSetting_string: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                key: m::SettingsKeyT,
                outValue: *mut *const ::std::os::raw::c_char,
            ) -> m::ErrorT,
        >,
        #[doc = " Sets the value of the setting with the given key. Note that this function can only be used for settings whose"]
        #[doc = " value is a bool!"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param key The key to the desired setting"]
        #[doc = " @param value The value that should be set for the given setting"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub setMumbleSetting_bool: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                key: m::SettingsKeyT,
                value: bool,
            ) -> m::ErrorT,
        >,
        #[doc = " Sets the value of the setting with the given key. Note that this function can only be used for settings whose"]
        #[doc = " value is an int!"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param key The key to the desired setting"]
        #[doc = " @param value The value that should be set for the given setting"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub setMumbleSetting_int: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                key: m::SettingsKeyT,
                value: i64,
            ) -> m::ErrorT,
        >,
        #[doc = " Sets the value of the setting with the given key. Note that this function can only be used for settings whose"]
        #[doc = " value is a double!"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param key The key to the desired setting"]
        #[doc = " @param value The value that should be set for the given setting"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub setMumbleSetting_double: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                key: m::SettingsKeyT,
                value: f64,
            ) -> m::ErrorT,
        >,
        #[doc = " Sets the value of the setting with the given key. Note that this function can only be used for settings whose"]
        #[doc = " value is a string!"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param key The key to the desired setting"]
        #[doc = " @param value The value that should be set for the given setting"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub setMumbleSetting_string: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                key: m::SettingsKeyT,
                value: *const ::std::os::raw::c_char,
            ) -> m::ErrorT,
        >,
        #[doc = " Sends the provided data to the provided client(s). This kind of data can only be received by another plugin"]
        #[doc = " active on that client. The sent data can be seen by any active plugin on the receiving client. Therefore the"]
        #[doc = " sent data must not contain sensitive information or anything else that shouldn't be known by others."]
        #[doc = ""]
        #[doc = " NOTE: Messages sent via this API function are rate-limited by the server. If the rate-limit is hit, the message"]
        #[doc = " will be dropped without an error message. The rate-limiting is global (e.g. it doesn't matter which plugin sent"]
        #[doc = " the respective messages - they all count to the same limit)."]
        #[doc = " Therefore if you have multiple messages to send, you should consider sending them asynchronously one at a time"]
        #[doc = " with a little delay in between (~1 second)."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to send the data through (the server the given users are on)"]
        #[doc = " @param users An array of user IDs to send the data to"]
        #[doc = " @param userCount The size of the provided user-array"]
        #[doc = " @param data The data array that shall be sent. This can be an arbitrary sequence of bytes. Note that the size of"]
        #[doc = " is restricted to <= 1KB."]
        #[doc = " @param dataLength The length of the data array"]
        #[doc = " @param dataID The ID of the sent data. This has to be used by the receiving plugin(s) to figure out what to do"]
        #[doc = " with the data. This has to be a C-encoded String. It is recommended that the ID starts with a plugin-specific"]
        #[doc = " prefix in order to avoid name clashes. Note that the size of this string is restricted to <= 100 bytes."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub sendData: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                connection: m::ConnectionT,
                users: *const m::UserIdT,
                userCount: usize,
                data: *const u8,
                dataLength: usize,
                dataID: *const ::std::os::raw::c_char,
            ) -> m::ErrorT,
        >,
        #[doc = " Logs the given message (typically to Mumble's console). All passed strings have to be UTF-8 encoded."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param message The message to log"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub log: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                message: *const ::std::os::raw::c_char,
            ) -> m::ErrorT,
        >,
        #[doc = " Plays the provided sample. It uses libsndfile as a backend so the respective file format needs to be supported"]
        #[doc = " by it in order for this to work out (see http://www.mega-nerd.com/libsndfile/)."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param samplePath The path to the sample that shall be played (UTF-8 encoded)"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub playSample: ::std::option::Option<
            unsafe extern "C" fn(
                callerID: m::PluginId,
                samplePath: *const ::std::os::raw::c_char,
            ) -> m::ErrorT,
        >,
    }
    #[test]
    fn bindgen_test_layout_MumbleAPI() {
        assert_eq!(
            ::std::mem::size_of::<MumbleAPI>(),
            152usize,
            concat!("Size of: ", stringify!(MumbleAPI))
        );
        assert_eq!(
            ::std::mem::align_of::<MumbleAPI>(),
            4usize,
            concat!("Alignment of ", stringify!(MumbleAPI))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).freeMemory as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(freeMemory)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).getActiveServerConnection as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getActiveServerConnection)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).isConnectionSynchronized as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(isConnectionSynchronized)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getLocalUserID as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getLocalUserID)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getUserName as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getUserName)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getChannelName as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getChannelName)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getAllUsers as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getAllUsers)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getAllChannels as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getAllChannels)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getChannelOfUser as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getChannelOfUser)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getUsersInChannel as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getUsersInChannel)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).getLocalUserTransmissionMode as *const _
                    as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getLocalUserTransmissionMode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).isUserLocallyMuted as *const _ as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(isUserLocallyMuted)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).isLocalUserMuted as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(isLocalUserMuted)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).isLocalUserDeafened as *const _ as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(isLocalUserDeafened)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getUserHash as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getUserHash)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getServerHash as *const _ as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getServerHash)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getUserComment as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getUserComment)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).getChannelDescription as *const _ as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getChannelDescription)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).requestLocalUserTransmissionMode as *const _
                    as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestLocalUserTransmissionMode)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).requestUserMove as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestUserMove)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).requestMicrophoneActivationOvewrite
                    as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestMicrophoneActivationOvewrite)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).requestLocalMute as *const _ as usize },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestLocalMute)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).requestLocalUserMute as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestLocalUserMute)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).requestLocalUserDeaf as *const _ as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestLocalUserDeaf)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).requestSetLocalUserComment as *const _
                    as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestSetLocalUserComment)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).findUserByName as *const _ as usize },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(findUserByName)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).findChannelByName as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(findChannelByName)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).getMumbleSetting_bool as *const _ as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getMumbleSetting_bool)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).getMumbleSetting_int as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getMumbleSetting_int)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).getMumbleSetting_double as *const _ as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getMumbleSetting_double)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).getMumbleSetting_string as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getMumbleSetting_string)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).setMumbleSetting_bool as *const _ as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(setMumbleSetting_bool)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).setMumbleSetting_int as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(setMumbleSetting_int)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).setMumbleSetting_double as *const _ as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(setMumbleSetting_double)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).setMumbleSetting_string as *const _ as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(setMumbleSetting_string)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).sendData as *const _ as usize },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(sendData)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).log as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(log)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).playSample as *const _ as usize },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(playSample)
            )
        );
    }
    extern "C" {
        #[doc = " Gets called right after loading the plugin in order to let the plugin initialize."]
        #[doc = ""]
        #[doc = " Registers the ID of this plugin."]
        #[doc = " @param id The ID for this plugin. This is the ID Mumble will reference this plugin with"]
        #[doc = " and by which this plugin can identify itself when communicating with Mumble."]
        #[doc = " @returns The status of the initialization. If everything went fine, return STATUS_OK"]
        pub fn mumble_init(id: m::PluginId) -> m::ErrorT;
    }
    extern "C" {
        #[doc = " Gets called when unloading the plugin in order to allow it to clean up after itself."]
        #[doc = " Note that it is still safe to call API functions from within this callback."]
        pub fn mumble_shutdown();
    }
    extern "C" {
        #[doc = " Gets the name of the plugin."]
        #[doc = ""]
        #[doc = " NOTE: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " @returns A String-wrapper containing the requested name"]
        pub fn mumble_getName() -> m::MumbleStringWrapper;
    }
    extern "C" {
        #[doc = " Gets the Version of the plugin-API this plugin intends to use."]
        #[doc = " Mumble will decide whether this plugin is loadable or not based on the return value of this function."]
        #[doc = ""]
        #[doc = " NOTE: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " @returns The respective API Version"]
        pub fn mumble_getAPIVersion() -> m::VersionT;
    }
    extern "C" {
        #[doc = " Provides the MumbleAPI struct to the plugin. This struct contains function pointers that can be used"]
        #[doc = " to interact with the Mumble client. It is up to the plugin to store this struct somewhere if it wants to make use"]
        #[doc = " of it at some point."]
        #[doc = ""]
        #[doc = " NOTE: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " @param api A pointer to the MumbleAPI struct. The API struct must be cast to the version corresponding to the"]
        #[doc = " user API version. If your plugin is e.g. using the 1.0.x API, then you have to cast this pointer to"]
        #[doc = " MumbleAPI_v_1_0_x. Note also that you **must not store this pointer**. It will become invalid. Therefore"]
        #[doc = " you have to copy the struct in order to use it later on."]
        pub fn mumble_registerAPIFunctions(apiStruct: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[doc = " Releases the resource pointed to by the given pointer. If the respective resource has been allocated before,"]
        #[doc = " this would be the time to free/delete it."]
        #[doc = " The resources processed by this functions are only those that have been specifically allocated in order to return"]
        #[doc = " them in one of the plugin functions to Mumble (e.g. the String returned by mumble_getName) and has nothing to do"]
        #[doc = " with your plugin's internal resource management."]
        #[doc = " In short: Only resources passed from the plugin to Mumble via a return value may be processed by this function."]
        #[doc = ""]
        #[doc = " NOTE1: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " NOTE2: that the pointer might be pointing to memory that had to be allocated without the plugin being loaded."]
        #[doc = " Therefore you should be very sure that there'll be another callback in which you want to free this memory,"]
        #[doc = " should you decide to not do it here (which is hereby explicitly advised against)."]
        #[doc = ""]
        #[doc = " NOTE3: The pointer is const as Mumble won't mess with the memory allocated by the plugin (no modifications)."]
        #[doc = " Nontheless this function is explicitly responsible for freeing the respective memory parts. If the memory has"]
        #[doc = " been allocated using malloc(), it needs to be freed using free() which requires a const-cast. If however the"]
        #[doc = " memory has been created using the new operator you have to cast the pointer back to its original type and then"]
        #[doc = " use the  delete operator on it (no const-cast necessary in this case)."]
        #[doc = " See https://stackoverflow.com/questions/2819535/unable-to-free-const-pointers-in-c"]
        #[doc = " and https://stackoverflow.com/questions/941832/is-it-safe-to-delete-a-void-pointer"]
        #[doc = ""]
        #[doc = " @param pointer The pointer to the memory that needs free-ing"]
        pub fn mumble_releaseResource(pointer: *const ::std::os::raw::c_void);
    }
    extern "C" {
        #[doc = " Tells the plugin some basic information about the Mumble client loading it."]
        #[doc = " This function will be the first one that is being called on this plugin - even before it is decided whether to load"]
        #[doc = " the plugin at all."]
        #[doc = ""]
        #[doc = " @param mumbleVersion The Version of the Mumble client"]
        #[doc = " @param mumbleAPIVersion The Version of the plugin-API the Mumble client runs with"]
        #[doc = " @param minimumExpectedAPIVersion The minimum Version the Mumble clients expects this plugin to meet in order to load"]
        #[doc = " it"]
        pub fn mumble_setMumbleInfo(
            mumbleVersion: m::VersionT,
            mumbleAPIVersion: m::VersionT,
            minimumExpectedAPIVersion: m::VersionT,
        );
    }
    extern "C" {
        #[doc = " Gets the Version of this plugin"]
        #[doc = ""]
        #[doc = " NOTE: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " @returns The plugin's version"]
        pub fn mumble_getVersion() -> m::VersionT;
    }
    extern "C" {
        #[doc = " Gets the name of the plugin author(s)."]
        #[doc = ""]
        #[doc = " NOTE: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " @returns A String-wrapper containing the requested author name(s)"]
        pub fn mumble_getAuthor() -> m::MumbleStringWrapper;
    }
    extern "C" {
        #[doc = " Gets the description of the plugin."]
        #[doc = ""]
        #[doc = " NOTE: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " @returns A String-wrapper containing the requested description"]
        pub fn mumble_getDescription() -> m::MumbleStringWrapper;
    }
    extern "C" {
        #[doc = " Gets the feature set of this plugin. The feature set is described by bitwise or'ing the elements of the"]
        #[doc = " Mumble_PluginFeature enum together."]
        #[doc = ""]
        #[doc = " NOTE: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " @returns The feature set of this plugin"]
        pub fn mumble_getFeatures() -> u32;
    }
    extern "C" {
        #[doc = " Requests this plugin to deactivate the given (sub)set of provided features."]
        #[doc = " If this is not possible, the features that can't be deactivated shall be returned by this function."]
        #[doc = ""]
        #[doc = " Example (check if FEATURE_POSITIONAL shall be deactivated):"]
        #[doc = " @code"]
        #[doc = " if (features & FEATURE_POSITIONAL) {"]
        #[doc = " // positional shall be deactivated"]
        #[doc = " };"]
        #[doc = " @endcode"]
        #[doc = ""]
        #[doc = " @param features The feature set that shall be deactivated"]
        #[doc = " @returns The feature set that can't be disabled (bitwise or'ed). If all requested features can be disabled, return"]
        #[doc = " FEATURE_NONE. If none of the requested features can be disabled return the unmodified features parameter."]
        pub fn mumble_deactivateFeatures(features: u32) -> u32;
    }
    extern "C" {
        #[doc = " Indicates that Mumble wants to use this plugin to request positional data. Therefore it should check whether it is"]
        #[doc = " currently able to do so and allocate memory that is needed for that process. As a parameter this function gets an"]
        #[doc = " array of names and an array of PIDs. They are of same length and the PID at index i belongs to a program whose name"]
        #[doc = " is listed at index i in the \"name-array\"."]
        #[doc = ""]
        #[doc = " @param programNames An array of pointers to the program names"]
        #[doc = " @param programPIDs An array of the corresponding program PIDs"]
        #[doc = " @param programCount The length of programNames and programPIDs"]
        #[doc = " @returns The error code. If everything went fine PDEC_OK shall be returned. In that case Mumble will start"]
        #[doc = " frequently calling fetchPositionalData. If this returns anything but PDEC_OK, Mumble will assume that the plugin is"]
        #[doc = " (currently) uncapable of providing positional data. In this case this function must not have allocated any memory"]
        #[doc = " that needs to be cleaned up later on. Depending on the returned error code, Mumble might try to call this function"]
        #[doc = " again at some point."]
        pub fn mumble_initPositionalData(
            programNames: *const *const ::std::os::raw::c_char,
            programPIDs: *const u64,
            programCount: usize,
        ) -> u8;
    }
    extern "C" {
        #[doc = " Retrieves the positional data. If no data can be fetched, set all float-vectors to 0 and return false."]
        #[doc = ""]
        #[doc = " @param[out] avatarPos A float-array of size 3 representing the cartesian position of the player/avatar in the ingame"]
        #[doc = " world. One unit represents one meter of distance."]
        #[doc = " @param[out] avatarDir A float-array of size 3 representing the cartesian direction-vector of the player/avatar"]
        #[doc = " ingame (where it is facing)."]
        #[doc = " @param[out] avatarAxis A float-array of size 3 representing the vector pointing from the toes of the character to"]
        #[doc = " its head. One unit represents one meter of distance."]
        #[doc = " @param[out] cameraPos A float-array of size 3 representing the cartesian position of the camera in the ingame world."]
        #[doc = " One unit represents one meter of distance."]
        #[doc = " @param[out] cameraDir A float-array of size 3 representing the cartesian direction-vector of the camera ingame"]
        #[doc = " (where it is facing)."]
        #[doc = " @param[out] cameraAxis A float-array of size 3 representing a vector from the bottom of the camera to its top. One"]
        #[doc = " unit represents one meter of distance."]
        #[doc = " @param[out] context A pointer to where the pointer to a C-encoded string storing the context of the provided"]
        #[doc = " positional data shall be written. This context should include information about the server (and team) the player is"]
        #[doc = " on. Only players with identical context will be able to hear each other's audio. The returned pointer has to remain"]
        #[doc = " valid until the next invokation of this function or until shutdownPositionalData is called."]
        #[doc = " @param[out] identity A pointer to where the pointer to a C-encoded string storing the identity of the player shall"]
        #[doc = " be written. It can be polled by external scripts from the server and should uniquely identify the player in the"]
        #[doc = " game. The pointer has to remain valid until the next invokation of this function or until shutdownPositionalData is"]
        #[doc = " called."]
        #[doc = " @returns Whether this plugin can continue delivering positional data. If this function returns false,"]
        #[doc = " shutdownPositionalData will be called."]
        pub fn mumble_fetchPositionalData(
            avatarPos: *mut f32,
            avatarDir: *mut f32,
            avatarAxis: *mut f32,
            cameraPos: *mut f32,
            cameraDir: *mut f32,
            cameraAxis: *mut f32,
            context: *mut *const ::std::os::raw::c_char,
            identity: *mut *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Indicates that this plugin will not be asked for positional data any longer. Thus any memory allocated for this"]
        #[doc = " purpose should be freed at this point."]
        pub fn mumble_shutdownPositionalData();
    }
    extern "C" {
        #[doc = " Called when connecting to a server."]
        #[doc = " Note that in most cases you'll want to use mumble_onServerSynchronized instead."]
        #[doc = " Note also that this callback will be called from a DIFFERENT THREAD!"]
        #[doc = ""]
        #[doc = " @param connection The ID of the newly established server-connection"]
        pub fn mumble_onServerConnected(connection: m::ConnectionT);
    }
    extern "C" {
        #[doc = " Called when disconnecting from a server."]
        #[doc = " Note that this callback is called from a DIFFERENT THREAD!"]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection that has been terminated"]
        pub fn mumble_onServerDisconnected(connection: m::ConnectionT);
    }
    extern "C" {
        #[doc = " Called when the client has finished synchronizing with the server"]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection that has been terminated"]
        pub fn mumble_onServerSynchronized(connection: m::ConnectionT);
    }
    extern "C" {
        #[doc = " Called whenever any user on the server enters a channel"]
        #[doc = " This function will also be called when freshly connecting to a server as each user on that"]
        #[doc = " server needs to be \"added\" to the respective channel as far as the local client is concerned."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection this event is connected to"]
        #[doc = " @param userID The ID of the user this event has been triggered for"]
        #[doc = " @param previousChannelID The ID of the chanel the user is coming from. Negative IDs indicate that there is no"]
        #[doc = " previous channel (e.g. the user freshly connected to the server) or the channel isn't available because of any other"]
        #[doc = " reason."]
        #[doc = " @param newChannelID The ID of the channel the user has entered. If the ID is negative, the new channel could not be"]
        #[doc = " retrieved. This means that the ID is invalid."]
        pub fn mumble_onChannelEntered(
            connection: m::ConnectionT,
            userID: m::UserIdT,
            previousChannelID: m::ChannelIdT,
            newChannelID: m::ChannelIdT,
        );
    }
    extern "C" {
        #[doc = " Called whenever a user leaves a channel."]
        #[doc = " This includes a client disconnecting from the server as this will also lead to the user not being in that channel"]
        #[doc = " anymore."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection this event is connected to"]
        #[doc = " @param userID The ID of the user that left the channel"]
        #[doc = " @param channelID The ID of the channel the user left. If the ID is negative, the channel could not be retrieved."]
        #[doc = " This means that the ID is invalid."]
        pub fn mumble_onChannelExited(
            connection: m::ConnectionT,
            userID: m::UserIdT,
            channelID: m::ChannelIdT,
        );
    }
    extern "C" {
        #[doc = " Called when any user changes his/her talking state."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection this event is connected to"]
        #[doc = " @param userID The ID of the user whose talking state has been changed"]
        #[doc = " @param talkingState The new TalkingState the user has switched to."]
        pub fn mumble_onUserTalkingStateChanged(
            connection: m::ConnectionT,
            userID: m::UserIdT,
            talkingState: m::TalkingStateT,
        );
    }
    extern "C" {
        #[doc = " Called whenever there is audio input."]
        #[doc = " Note that this callback will be called from the AUDIO THREAD."]
        #[doc = " Note also that blocking this callback will cause Mumble's audio processing to get suspended."]
        #[doc = ""]
        #[doc = " @param inputPCM A pointer to a short-array holding the pulse-code-modulation (PCM) representing the audio input. Its"]
        #[doc = " length is sampleCount * channelCount. The PCM format for stereo input is [LRLRLR...] where L and R are samples of"]
        #[doc = " the left and right channel respectively."]
        #[doc = " @param sampleCount The amount of sample points per channel"]
        #[doc = " @param channelCount The amount of channels in the audio"]
        #[doc = " @param sampleRate The used sample rate in Hz"]
        #[doc = " @param isSpeech A boolean flag indicating whether Mumble considers the input as part of speech (instead of"]
        #[doc = " background noise)"]
        #[doc = " @returns Whether this callback has modified the audio input-array"]
        pub fn mumble_onAudioInput(
            inputPCM: *mut ::std::os::raw::c_short,
            sampleCount: u32,
            channelCount: u16,
            sampleRate: u32,
            isSpeech: bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Called whenever Mumble fetches data from an active audio source (could be a voice packet or a playing sample)."]
        #[doc = " The provided audio buffer is the raw buffer without any processing applied to it yet."]
        #[doc = " Note that this callback will be called from the AUDIO THREAD."]
        #[doc = " Note also that blocking this callback will cause Mumble's audio processing to get suspended."]
        #[doc = ""]
        #[doc = " @param outputPCM A pointer to a float-array holding the pulse-code-modulation (PCM) representing the audio output."]
        #[doc = " Its length is sampleCount * channelCount. The PCM format for stereo output is [LRLRLR...] where L and R are samples"]
        #[doc = " of the left and right channel respectively."]
        #[doc = " @param sampleCount The amount of sample points per channel"]
        #[doc = " @param channelCount The amount of channels in the audio"]
        #[doc = " @param sampleRate The used sample rate in Hz"]
        #[doc = " @param isSpeech Whether this audio belongs to a received voice packet (and will thus (most likely) contain speech)"]
        #[doc = " @param userID If isSpeech is true, this contains the ID of the user this voice packet belongs to. If isSpeech is"]
        #[doc = " false, the content of this parameter is unspecified and should not be accessed"]
        #[doc = " @returns Whether this callback has modified the audio output-array"]
        pub fn mumble_onAudioSourceFetched(
            outputPCM: *mut f32,
            sampleCount: u32,
            channelCount: u16,
            sampleRate: u32,
            isSpeech: bool,
            userID: m::UserIdT,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Called whenever the fully mixed and processed audio is about to be handed to the audio backend (about to be played)."]
        #[doc = " Note that this happens immediately before Mumble clips the audio buffer."]
        #[doc = " Note that this callback will be called from the AUDIO THREAD."]
        #[doc = " Note also that blocking this callback will cause Mumble's audio processing to get suspended."]
        #[doc = ""]
        #[doc = " @param outputPCM A pointer to a float-array holding the pulse-code-modulation (PCM) representing the audio output."]
        #[doc = " Its length is sampleCount * channelCount. The PCM format for stereo output is [LRLRLR...] where L and R are samples"]
        #[doc = " of the left and right channel respectively."]
        #[doc = " @param sampleCount The amount of sample points per channel"]
        #[doc = " @param channelCount The amount of channels in the audio"]
        #[doc = " @param sampleRate The used sample rate in Hz"]
        #[doc = " @returns Whether this callback has modified the audio output-array"]
        pub fn mumble_onAudioOutputAboutToPlay(
            outputPCM: *mut f32,
            sampleCount: u32,
            channelCount: u16,
            sampleRate: u32,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Called whenever data has been received that has been sent by a plugin. This data should only be processed by the"]
        #[doc = " intended plugin. For this reason a dataID is provided that should be used to determine whether the data is intended"]
        #[doc = " for this plugin or not. As soon as the data has been processed, no further plugins will be notified about it."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection the data is coming from"]
        #[doc = " @param sender The ID of the user whose client's plugin has sent the data"]
        #[doc = " @param data The sent data array. This can be an arbitrary sequence of bytes."]
        #[doc = " @param dataLength The length of the data array"]
        #[doc = " @param dataID The ID of this data (C-encoded)"]
        #[doc = " @return Whether the given data has been processed by this plugin"]
        pub fn mumble_onReceiveData(
            connection: m::ConnectionT,
            sender: m::UserIdT,
            data: *const u8,
            dataLength: usize,
            dataID: *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Called when a new user gets added to the user model. This is the case when that new user freshly connects to the"]
        #[doc = " server the local user is on but also when the local user connects to a server other clients are already connected to"]
        #[doc = " (in this case this method will be called for every client already on that server)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param userID The ID of the user that has been added"]
        pub fn mumble_onUserAdded(connection: m::ConnectionT, userID: m::UserIdT);
    }
    extern "C" {
        #[doc = " Called when a user gets removed from the user model. This is the case when that user disconnects from the server the"]
        #[doc = " local user is on but also when the local user disconnects from a server other clients are connected to (in this case"]
        #[doc = " this method will be called for every client on that server)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param userID The ID of the user that has been removed"]
        pub fn mumble_onUserRemoved(connection: m::ConnectionT, userID: m::UserIdT);
    }
    extern "C" {
        #[doc = " Called when a new channel gets added to the user model. This is the case when a new channel is created on the server"]
        #[doc = " the local user is on but also when the local user connects to a server that contains channels other than the"]
        #[doc = " root-channel (in this case this method will be called for ever non-root channel on that server)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param channelID The ID of the channel that has been added"]
        pub fn mumble_onChannelAdded(connection: m::ConnectionT, channelID: m::ChannelIdT);
    }
    extern "C" {
        #[doc = " Called when a channel gets removed from the user model. This is the case when a channel is removed on the server the"]
        #[doc = " local user is on but also when the local user disconnects from a server that contains channels other than the"]
        #[doc = " root-channel (in this case this method will be called for ever non-root channel on that server)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param channelID The ID of the channel that has been removed"]
        pub fn mumble_onChannelRemoved(connection: m::ConnectionT, channelID: m::ChannelIdT);
    }
    extern "C" {
        #[doc = " Called when a channel gets renamed. This also applies when a new channel is created (thus assigning it an initial"]
        #[doc = " name is also considered renaming)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param channelID The ID of the channel that has been renamed"]
        pub fn mumble_onChannelRenamed(connection: m::ConnectionT, channelID: m::ChannelIdT);
    }
    extern "C" {
        #[doc = " Called when a key has been pressed or released while Mumble has keyboard focus."]
        #[doc = " Note that this callback will only work if the user has explicitly given permission to monitor keyboard"]
        #[doc = " events for this plugin. Thus if you want to use this callback, make sure your users know that they have to"]
        #[doc = " enable that."]
        #[doc = ""]
        #[doc = " @param keyCode The key code of the respective key. The character codes are defined"]
        #[doc = " via the Mumble_KeyCode enum. For printable 7-bit ASCII characters these codes conform"]
        #[doc = " to the ASCII code-page with the only difference that case is not distinguished. Therefore"]
        #[doc = " always the upper-case letter code will be used for letters."]
        #[doc = " @param wasPres Whether the respective key has been pressed (instead of released)"]
        pub fn mumble_onKeyEvent(keyCode: u32, wasPress: bool);
    }
    extern "C" {
        #[doc = " This function is used to determine whether the plugin can find an update for itself that is available for download."]
        #[doc = ""]
        #[doc = " NOTE: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " @return Whether the plugin was able to find an update for itself"]
        pub fn mumble_hasUpdate() -> bool;
    }
    extern "C" {
        #[doc = " This function is used to retrieve the URL for downloading the newer/updated version of this plugin."]
        #[doc = ""]
        #[doc = " NOTE: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " @returns A String-wrapper containing the requested URL"]
        pub fn mumble_getUpdateDownloadURL() -> m::MumbleStringWrapper;
    }
}
