/* automatically generated by rust-bindgen 0.55.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct __uint8_t(pub ::std::os::raw::c_uchar);
    impl ::std::ops::Deref for __uint8_t {
        type Target = ::std::os::raw::c_uchar;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for __uint8_t {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct __uint16_t(pub ::std::os::raw::c_ushort);
    impl ::std::ops::Deref for __uint16_t {
        type Target = ::std::os::raw::c_ushort;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for __uint16_t {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct __int32_t(pub ::std::os::raw::c_int);
    impl ::std::ops::Deref for __int32_t {
        type Target = ::std::os::raw::c_int;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for __int32_t {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct __uint32_t(pub ::std::os::raw::c_uint);
    impl ::std::ops::Deref for __uint32_t {
        type Target = ::std::os::raw::c_uint;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for __uint32_t {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct __uint64_t(pub ::std::os::raw::c_ulong);
    impl ::std::ops::Deref for __uint64_t {
        type Target = ::std::os::raw::c_ulong;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for __uint64_t {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod __detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    #[repr(i32)]
    #[doc = " This enum's values represent talking states a user can be in when using Mumble."]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum Mumble_TalkingState {
        INVALID = -1,
        PASSIVE = 0,
        TALKING = 1,
        WHISPERING = 2,
        SHOUTING = 3,
    }
    #[repr(u32)]
    #[doc = " This enum's values represent transmission modes a user might have configured. Transmission mode"]
    #[doc = " in this context is referring to a method that determines when a user is speaking and thus when"]
    #[doc = " to transmit audio packets."]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum Mumble_TransmissionMode {
        TM_CONTINOUS = 0,
        TM_VOICE_ACTIVATION = 1,
        TM_PUSH_TO_TALK = 2,
    }
    #[repr(i32)]
    #[doc = " This enum's values represent the error codes that are being used by the MumbleAPI."]
    #[doc = " You can get a string-representation for each error code via the errorMessage function."]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum Mumble_ErrorCode {
        EC_INTERNAL_ERROR = -2,
        EC_GENERIC_ERROR = -1,
        EC_OK = 0,
        EC_POINTER_NOT_FOUND = 1,
        EC_NO_ACTIVE_CONNECTION = 2,
        EC_USER_NOT_FOUND = 3,
        EC_CHANNEL_NOT_FOUND = 4,
        EC_CONNECTION_NOT_FOUND = 5,
        EC_UNKNOWN_TRANSMISSION_MODE = 6,
        EC_AUDIO_NOT_AVAILABLE = 7,
        EC_INVALID_SAMPLE = 8,
        EC_INVALID_PLUGIN_ID = 9,
        EC_INVALID_MUTE_TARGET = 10,
        EC_CONNECTION_UNSYNCHRONIZED = 11,
        EC_INVALID_API_VERSION = 12,
        EC_UNSYNCHRONIZED_BLOB = 13,
    }
    #[doc = " A struct for representing a version of the form major.minor.patch"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct Version {
        pub major: i32,
        pub minor: i32,
        pub patch: i32,
    }
    #[test]
    fn bindgen_test_layout_Version() {
        assert_eq!(
            ::std::mem::size_of::<Version>(),
            12usize,
            concat!("Size of: ", stringify!(Version))
        );
        assert_eq!(
            ::std::mem::align_of::<Version>(),
            4usize,
            concat!("Alignment of ", stringify!(Version))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Version>())).major as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Version),
                "::",
                stringify!(major)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Version>())).minor as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Version),
                "::",
                stringify!(minor)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Version>())).patch as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Version),
                "::",
                stringify!(patch)
            )
        );
    }
    #[doc = " Typedef for the type of a talking state"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct talking_state_t(pub root::Mumble_TalkingState);
    impl ::std::ops::Deref for talking_state_t {
        type Target = root::Mumble_TalkingState;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for talking_state_t {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of a transmission mode"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct transmission_mode_t(pub root::Mumble_TransmissionMode);
    impl ::std::ops::Deref for transmission_mode_t {
        type Target = root::Mumble_TransmissionMode;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for transmission_mode_t {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of a version"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct version_t(pub root::Version);
    impl ::std::ops::Deref for version_t {
        type Target = root::Version;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for version_t {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of a connection"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct mumble_connection_t(pub i32);
    impl ::std::ops::Deref for mumble_connection_t {
        type Target = i32;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for mumble_connection_t {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of a user"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct mumble_userid_t(pub u32);
    impl ::std::ops::Deref for mumble_userid_t {
        type Target = u32;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for mumble_userid_t {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of a channel"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct mumble_channelid_t(pub i32);
    impl ::std::ops::Deref for mumble_channelid_t {
        type Target = i32;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for mumble_channelid_t {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    #[doc = " Typedef for the type of an error (code)"]
    pub use self::super::root::Mumble_ErrorCode as mumble_error_t;
    #[doc = " Typedef for the type of a plugin ID"]
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct plugin_id_t(pub u32);
    impl ::std::ops::Deref for plugin_id_t {
        type Target = u32;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl ::std::ops::DerefMut for plugin_id_t {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    extern "C" {
        #[link_name = "\u{1}_ZL25MUMBLE_PLUGIN_API_VERSION"]
        pub static MUMBLE_PLUGIN_API_VERSION: root::version_t;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct MumbleAPI {
        #[doc = " Frees the given pointer."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param pointer The pointer to free"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub freeMemory: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                pointer: *const ::std::os::raw::c_void,
            ) -> root::mumble_error_t,
        #[doc = " Gets the connection ID of the server the user is currently active on (the user's audio output is directed at)."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param[out] connection A pointer to the memory location the ID should be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then it is valid to access the"]
        #[doc = " \tvalue of the provided pointer"]
        pub getActiveServerConnection: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: *mut root::mumble_connection_t,
            ) -> root::mumble_error_t,
        #[doc = " Checks whether the given connection has finished initializing yet."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param[out] A pointer to the boolean variable that'll hold the info whether the server has finished synchronization yet"]
        #[doc = " \tafter this function has executed successfully."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub isConnectionSynchronized: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                synchronized: *mut bool,
            ) -> root::mumble_error_t,
        #[doc = " Fills in the information about the local user."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param[out] userID A pointer to the memory the user's ID shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getLocalUserID: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: *mut root::mumble_userid_t,
            ) -> root::mumble_error_t,
        #[doc = " Fills in the information about the given user's name."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The user's ID whose name should be obtained"]
        #[doc = " @param[out] userName A pointer to where the pointer to the allocated string (C-encoded) should be written to. The"]
        #[doc = " \tallocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " \tallocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getUserName: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: root::mumble_userid_t,
                userName: *mut *mut ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        #[doc = " Fills in the information about the given channel's name."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param channelID The channel's ID whose name should be obtained"]
        #[doc = " @param[out] channelName A pointer to where the pointer to the allocated string (C-ecoded) should be written to. The"]
        #[doc = " \tallocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " \tallocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getChannelName: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                channelID: root::mumble_channelid_t,
                channelName: *mut *mut ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        #[doc = " Gets an array of all users that are currently connected to the provided server. Passing a nullptr as any of the out-parameter"]
        #[doc = " will prevent that property to be set/allocated. If you are only interested in the user count you can thus pass nullptr as the"]
        #[doc = " users parameter and save time on allocating + freeing the channels-array while still getting the size out."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param[out] users A pointer to where the pointer of the allocated array shall be written. The"]
        #[doc = " \tallocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " \tallocated if this function returns STATUS_OK."]
        #[doc = " @param[out] userCount A pointer to where the size of the allocated user-array shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getAllUsers: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                users: *mut *mut root::mumble_userid_t,
                userCount: *mut usize,
            ) -> root::mumble_error_t,
        #[doc = " Gets an array of all channels on the provided server. Passing a nullptr as any of the out-parameter will prevent"]
        #[doc = " that property to be set/allocated. If you are only interested in the channel count you can thus pass nullptr as the"]
        #[doc = " channels parameter and save time on allocating + freeing the channels-array while still getting the size out."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param[out] channels A pointer to where the pointer of the allocated array shall be written. The"]
        #[doc = " \tallocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " \tallocated if this function returns STATUS_OK."]
        #[doc = " @param[out] channelCount A pointer to where the size of the allocated channel-array shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getAllChannels: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                channels: *mut *mut root::mumble_channelid_t,
                channelCount: *mut usize,
            ) -> root::mumble_error_t,
        #[doc = " Gets the ID of the channel the given user is currently connected to."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user to search for"]
        #[doc = " @param[out] A pointer to where the ID of the channel shall be written"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getChannelOfUser: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: root::mumble_userid_t,
                channel: *mut root::mumble_channelid_t,
            ) -> root::mumble_error_t,
        #[doc = " Gets an array of all users in the specified channel."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param channelID The ID of the channel whose users shall be retrieved"]
        #[doc = " @param[out] userList A pointer to where the pointer of the allocated array shall be written. The allocated memory has"]
        #[doc = " \tto be freed by a call to freeMemory by the plugin eventually. The memory will only be allocated if this function"]
        #[doc = " \treturns STATUS_OK."]
        #[doc = " @param[out] userCount A pointer to where the size of the allocated user-array shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getUsersInChannel: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                channelID: root::mumble_channelid_t,
                userList: *mut *mut root::mumble_userid_t,
                userCount: *mut usize,
            ) -> root::mumble_error_t,
        #[doc = " Gets the current transmission mode of the local user."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param[out] transmissionMode A pointer to where the transmission mode shall be written."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getLocalUserTransmissionMode: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                transmissionMode: *mut root::transmission_mode_t,
            ) -> root::mumble_error_t,
        #[doc = " Checks whether the given user is currently locally muted."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user to search for"]
        #[doc = " @param[out] muted A pointer to where the local mute state of that user shall be written"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub isUserLocallyMuted: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: root::mumble_userid_t,
                muted: *mut bool,
            ) -> root::mumble_error_t,
        #[doc = " Gets the hash of the given user (can be used to recognize users between restarts)"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user to search for"]
        #[doc = " @param[out] hash A pointer to where the pointer to the allocated string (C-encoded) should be written to. The"]
        #[doc = " \tallocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " \tallocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getUserHash: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: root::mumble_userid_t,
                hash: *mut *mut ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        #[doc = " Gets the hash of the server for the given connection (can be used to recognize servers between restarts)"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection"]
        #[doc = " @param[out] hash A pointer to where the pointer to the allocated string (C-encoded) should be written to. The"]
        #[doc = " \tallocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " \tallocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getServerHash: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                hash: *mut *mut ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        #[doc = " Gets the comment of the given user. Note that a user might have a comment configured that hasn't been synchronized"]
        #[doc = " to this client yet. In this case this function will return EC_UNSYNCHRONIZED_BLOB. As of now there is now way"]
        #[doc = " to request the synchronization to happen via the Plugin-API."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection"]
        #[doc = " @param userID the ID of the user whose comment should be obtained"]
        #[doc = " @param[out] comment A pointer to where the pointer to the allocated string (C-encoded) should be written to. The"]
        #[doc = " \tallocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " \tallocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getUserComment: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: root::mumble_userid_t,
                comment: *mut *mut ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        #[doc = " Gets the description of the given channel. Note that a channel might have a description configured that hasn't been synchronized"]
        #[doc = " to this client yet. In this case this function will return EC_UNSYNCHRONIZED_BLOB. As of now there is now way"]
        #[doc = " to request the synchronization to happen via the Plugin-API."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection"]
        #[doc = " @param channelID the ID of the channel whose comment should be obtained"]
        #[doc = " @param[out] description A pointer to where the pointer to the allocated string (C-encoded) should be written to. The"]
        #[doc = " \tallocated memory has to be freed by a call to freeMemory by the plugin eventually. The memory will only be"]
        #[doc = " \tallocated if this function returns STATUS_OK."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub getChannelDescription: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                channelID: root::mumble_channelid_t,
                description: *mut *mut ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        #[doc = " Requests Mumble to set the local user's transmission mode to the specified one. If you only need to temporarily set"]
        #[doc = " the transmission mode to continous, use requestMicrophoneActivationOverwrite instead as this saves you the work of"]
        #[doc = " restoring the previous state afterwards."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param transmissionMode The requested transmission mode"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestLocalUserTransmissionMode: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                transmissionMode: root::transmission_mode_t,
            ) -> root::mumble_error_t,
        #[doc = " Requests Mumble to move the given user into the given channel"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user that shall be moved"]
        #[doc = " @param channelID The ID of the channel to move the user to"]
        #[doc = " @param password The password of the target channel (UTF-8 encoded as a C-string). Pass NULL if the target channel does not require a"]
        #[doc = " \tpassword for entering"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestUserMove: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: root::mumble_userid_t,
                channelID: root::mumble_channelid_t,
                password: *const ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        #[doc = " Requests Mumble to overwrite the microphone activation so that the microphone is always on (same as if the user had chosen"]
        #[doc = " the continous transmission mode). If a plugin requests this overwrite, it is responsible for deactivating the overwrite again"]
        #[doc = " once it is no longer required"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param activate Whether to activate the overwrite (false deactivates an existing overwrite)"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestMicrophoneActivationOvewrite: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                activate: bool,
            ) -> root::mumble_error_t,
        #[doc = " Requests Mumble to set the local mute state of the given client. Note that this only affects the **local** mute state"]
        #[doc = " opposed to a server-mute (client is globally muted by the server) or the client's own mute-state (client has muted its"]
        #[doc = " microphone and thus isn't transmitting any audio)."]
        #[doc = " Furthermore it must be noted that muting the local user with this function does not work (it doesn't make sense). If"]
        #[doc = " you try to do so, this function will fail. In order to make this work, this function will also fail if the server"]
        #[doc = " has not finished synchronizing with the client yet."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function."]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userID The ID of the user that shall be moved"]
        #[doc = " @param muted Whether to locally mute the given client (opposed to unmuting it)"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub requestLocalMute: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userID: root::mumble_userid_t,
                muted: bool,
            ) -> root::mumble_error_t,
        #[doc = " Sets the comment of the local user"]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection"]
        #[doc = " @param comment The new comment to use (C-encoded). A subset of HTML formatting is supported."]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer"]
        #[doc = " \tmay be accessed"]
        pub requestSetLocalUserComment: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                comment: *const ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        #[doc = " Fills in the information about a user with the specified name, if such a user exists. The search is case-sensitive."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param userName The respective user's name"]
        #[doc = " @param[out] userID A pointer to the memory the user's ID shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer may"]
        #[doc = " \tbe accessed."]
        pub findUserByName: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                userName: *const ::std::os::raw::c_char,
                userID: *mut root::mumble_userid_t,
            ) -> root::mumble_error_t,
        #[doc = " Fills in the information about a channel with the specified name, if such a channel exists. The search is case-sensitive."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to use as a context"]
        #[doc = " @param channelName The respective channel's name"]
        #[doc = " @param[out] channelID A pointer to the memory the channel's ID shall be written to"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned. Only then the passed pointer may"]
        #[doc = " \tbe accessed."]
        pub findChannelByName: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                channelName: *const ::std::os::raw::c_char,
                channelID: *mut root::mumble_channelid_t,
            ) -> root::mumble_error_t,
        #[doc = " Sends the provided data to the provided client(s). This kind of data can only be received by another plugin active"]
        #[doc = " on that client. The sent data can be seen by any active plugin on the receiving client. Therefore the sent data"]
        #[doc = " must not contain sensitive information or anything else that shouldn't be known by others."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param connection The ID of the server-connection to send the data through (the server the given users are on)"]
        #[doc = " @param users An array of user IDs to send the data to"]
        #[doc = " @param userCount The size of the provided user-array"]
        #[doc = " @param data The data that shall be sent as a String"]
        #[doc = " @param dataLength The length of the data-string"]
        #[doc = " @param dataID The ID of the sent data. This has to be used by the receiving plugin(s) to figure out what to do with"]
        #[doc = " \tthe data"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub sendData: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                connection: root::mumble_connection_t,
                users: *mut root::mumble_userid_t,
                userCount: usize,
                data: *const ::std::os::raw::c_char,
                dataLength: usize,
                dataID: *const ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        #[doc = " Logs the given message (typically to Mumble's console). All passed strings have to be UTF-8 encoded."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param message The message to log"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub log: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                message: *const ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
        #[doc = " Plays the provided sample. It uses libsndfile as a backend so the respective file format needs to be supported by it"]
        #[doc = " in order for this to work out (see http://www.mega-nerd.com/libsndfile/)."]
        #[doc = ""]
        #[doc = " @param callerID The ID of the plugin calling this function"]
        #[doc = " @param samplePath The path to the sample that shall be played (UTF-8 encoded)"]
        #[doc = " @returns The error code. If everything went well, STATUS_OK will be returned."]
        pub playSample: unsafe extern "C" fn(
                callerID: root::plugin_id_t,
                samplePath: *const ::std::os::raw::c_char,
            ) -> root::mumble_error_t,
    }
    #[test]
    fn bindgen_test_layout_MumbleAPI() {
        assert_eq!(
            ::std::mem::size_of::<MumbleAPI>(),
            208usize,
            concat!("Size of: ", stringify!(MumbleAPI))
        );
        assert_eq!(
            ::std::mem::align_of::<MumbleAPI>(),
            8usize,
            concat!("Alignment of ", stringify!(MumbleAPI))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).freeMemory as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(freeMemory)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).getActiveServerConnection as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getActiveServerConnection)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).isConnectionSynchronized as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(isConnectionSynchronized)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getLocalUserID as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getLocalUserID)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getUserName as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getUserName)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getChannelName as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getChannelName)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getAllUsers as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getAllUsers)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getAllChannels as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getAllChannels)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getChannelOfUser as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getChannelOfUser)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getUsersInChannel as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getUsersInChannel)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).getLocalUserTransmissionMode as *const _
                    as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getLocalUserTransmissionMode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).isUserLocallyMuted as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(isUserLocallyMuted)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getUserHash as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getUserHash)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getServerHash as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getServerHash)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).getUserComment as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getUserComment)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).getChannelDescription as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(getChannelDescription)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).requestLocalUserTransmissionMode as *const _
                    as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestLocalUserTransmissionMode)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).requestUserMove as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestUserMove)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).requestMicrophoneActivationOvewrite
                    as *const _ as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestMicrophoneActivationOvewrite)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).requestLocalMute as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestLocalMute)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<MumbleAPI>())).requestSetLocalUserComment as *const _
                    as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(requestSetLocalUserComment)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).findUserByName as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(findUserByName)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).findChannelByName as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(findChannelByName)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).sendData as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(sendData)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).log as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(log)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<MumbleAPI>())).playSample as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(MumbleAPI),
                "::",
                stringify!(playSample)
            )
        );
    }
    extern "C" {
        #[doc = " Gets called right after loading the plugin in order to let the plugin initialize."]
        #[doc = ""]
        #[doc = " Registers the ID of this plugin."]
        #[doc = " @param id The ID for this plugin. This is the ID Mumble will reference this plugin with"]
        #[doc = " \tand by which this plugin can identify itself when communicating with Mumble."]
        #[doc = " @returns The status of the initialization. If everything went fine, return STATUS_OK"]
        pub fn mumble_init(id: u32) -> root::mumble_error_t;
    }
    extern "C" {
        #[doc = " Gets called when unloading the plugin in order to allow it to clean up after itself."]
        pub fn mumble_shutdown();
    }
    extern "C" {
        #[doc = " Gets the name of the plugin. The plugin has to guarantee that the returned pointer will still be valid. The string will be copied"]
        #[doc = " for further usage though."]
        #[doc = ""]
        #[doc = " @returns A pointer to the plugin name (encoded as a C-String)"]
        pub fn mumble_getName() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Gets the Version of the plugin-API this plugin intends to use."]
        #[doc = " Mumble will decide whether this plugin is loadable or not based on the return value of this function."]
        #[doc = ""]
        #[doc = " @return The respective API Version"]
        pub fn mumble_getAPIVersion() -> root::version_t;
    }
    extern "C" {
        #[doc = " Provides the MumbleAPI struct to the plugin. This struct contains function pointers that can be used"]
        #[doc = " to interact with the Mumble client. It is up to the plugin to store this struct somewhere if it wants to make use"]
        #[doc = " of it at some point."]
        #[doc = ""]
        #[doc = " @param api The MumbleAPI struct"]
        pub fn mumble_registerAPIFunctions(api: root::MumbleAPI);
    }
    extern "C" {
        #[doc = " Tells the plugin some basic information about the Mumble client loading it."]
        #[doc = " This function will be the first one that is being called on this plugin - even before it is decided whether to load"]
        #[doc = " the plugin at all."]
        #[doc = ""]
        #[doc = " @param mumbleVersion The Version of the Mumble client"]
        #[doc = " @param mumbleAPIVersion The Version of the plugin-API the Mumble client runs with"]
        #[doc = " @param minimalExpectedAPIVersion The minimal Version the Mumble clients expects this plugin to meet in order to load it"]
        pub fn mumble_setMumbleInfo(
            mumbleVersion: root::version_t,
            mumbleAPIVersion: root::version_t,
            minimalExpectedAPIVersion: root::version_t,
        );
    }
    extern "C" {
        #[doc = " Gets the Version of this plugin"]
        #[doc = ""]
        #[doc = " @returns The plugin's version"]
        pub fn mumble_getVersion() -> root::version_t;
    }
    extern "C" {
        #[doc = " Gets the name of the plugin author(s). The plugin has to guarantee that the returned pointer will still be valid. The string will"]
        #[doc = " be copied for further usage though."]
        #[doc = ""]
        #[doc = " @returns A pointer to the author(s) name(s) (encoded as a C-String)"]
        pub fn mumble_getAuthor() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Gets the description of the plugin. The plugin has to guarantee that the returned pointer will still be valid. The string will"]
        #[doc = " be copied for further usage though."]
        #[doc = ""]
        #[doc = " @returns A pointer to the description (encoded as a C-String)"]
        pub fn mumble_getDescription() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Gets the feature set of this plugin. The feature set is described by bitwise or'ing the elements of the Mumble_PluginFeature enum"]
        #[doc = " together."]
        #[doc = ""]
        #[doc = " @returns The feature set of this plugin"]
        pub fn mumble_getFeatures() -> u32;
    }
    extern "C" {
        #[doc = " Requests this plugin to deactivate the given (sub)set of provided features."]
        #[doc = " If this is not possible, the features that can't be deactivated shall be returned by this function."]
        #[doc = ""]
        #[doc = " Example (check if FEATURE_POSITIONAL shall be deactivated):"]
        #[doc = " @code"]
        #[doc = " if (features & FEATURE_POSITIONAL) {"]
        #[doc = " \t// positional shall be deactivated"]
        #[doc = " };"]
        #[doc = " @endcode"]
        #[doc = ""]
        #[doc = " @param features The feature set that shall be deactivated"]
        #[doc = " @returns The feature set that can't be disabled (bitwise or'ed). If all requested features can be disabled, return"]
        #[doc = " \tFEATURE_NONE. If none of the requested features can be disabled return the unmodified features parameter."]
        pub fn mumble_deactivateFeatures(features: u32) -> u32;
    }
    extern "C" {
        #[doc = " Indicates that Mumble wants to use this plugin to request positional data. Therefore it should check whether it is currently"]
        #[doc = " able to do so and allocate memory that is needed for that process."]
        #[doc = " As a parameter this function gets an array of names and an array of PIDs. They are of same length and the PID at index i"]
        #[doc = " belongs to a program whose name is listed at index i in the \"name-array\"."]
        #[doc = ""]
        #[doc = " @param programNames An array of pointers to the program names"]
        #[doc = " @param programPIDs An array of the corresponding program PIDs"]
        #[doc = " @param programCount The length of programNames and programPIDs"]
        #[doc = " @returns The error code. If everything went fine PDEC_OK shall be returned. In that case Mumble will start frequently"]
        #[doc = " \tcalling fetchPositionalData. If this returns anything but PDEC_OK, Mumble will assume that the plugin is (currently)"]
        #[doc = " \tuncapable of providing positional data. In this case this function must not have allocated any memory that needs to be"]
        #[doc = " \tcleaned up later on. Depending on the returned error code, Mumble might try to call this function again later on."]
        pub fn mumble_initPositionalData(
            programNames: *mut *const ::std::os::raw::c_char,
            programPIDs: *const u64,
            programCount: usize,
        ) -> u8;
    }
    extern "C" {
        #[doc = " Retrieves the positional audio data. If no data can be fetched, set all float-vectors to 0 and return false."]
        #[doc = ""]
        #[doc = " @param[out] avatarPos A float-array of size 3 representing the cartesian position of the player/avatar in the ingame world."]
        #[doc = " \tOne unit represents one meter of distance."]
        #[doc = " @param[out] avatarDir A float-array of size 3 representing the cartesian direction-vector of the player/avatar ingame (where it"]
        #[doc = " \tis facing)."]
        #[doc = " @param[out] avatarAxis A float-array of size 3 representing the vector pointing from the toes of the character to its head. One"]
        #[doc = " \tunit represents one meter of distance."]
        #[doc = " @param[out] cameraPos A float-array of size 3 representing the cartesian position of the camera in the ingame world."]
        #[doc = " \tOne unit represents one meter of distance."]
        #[doc = " @param[out] cameraDir A float-array of size 3 representing the cartesian direction-vector of the camera ingame (where it"]
        #[doc = " \tis facing)."]
        #[doc = " @param[out] cameraAxis A float-array of size 3 representing a vector from the bottom of the camera to its top. One unit"]
        #[doc = " \trepresents one meter of distance."]
        #[doc = " @param[out] context A pointer to where the pointer to a C-encoded string storing the context of the provided positional data"]
        #[doc = " \tshall be written. This context should include information about the server (and team) the player is on. Only players with identical"]
        #[doc = " \tcontext will be able to hear each other's audio. The returned pointer has to remain valid until the next invokation of this function"]
        #[doc = " \tor until shutdownPositionalData is called."]
        #[doc = " @param[out] identity A pointer to where the pointer to a C-encoded string storing the identity of the player shall be written. It can"]
        #[doc = " \tbe polled by external scripts from the server and should uniquely identify the player in the game. The pointer has to remain valid"]
        #[doc = " \tuntil the next invokation of this function or until shutdownPositionalData is called."]
        #[doc = " @returns Whether this plugin can continue delivering positional data. If this function returns false, shutdownPositionalData will"]
        #[doc = " \tbe called."]
        pub fn mumble_fetchPositionalData(
            avatarPos: *mut f32,
            avatarDir: *mut f32,
            avatarAxis: *mut f32,
            cameraPos: *mut f32,
            cameraDir: *mut f32,
            cameraAxis: *mut f32,
            context: *mut *const ::std::os::raw::c_char,
            identity: *mut *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Indicates that this plugin will not be asked for positional data any longer. Thus any memory allocated for this purpose should"]
        #[doc = " be freed at this point."]
        pub fn mumble_shutdownPositionalData();
    }
    extern "C" {
        #[doc = " Called when connecting to a server."]
        #[doc = ""]
        #[doc = " @param connection The ID of the newly established server-connection"]
        pub fn mumble_onServerConnected(connection: root::mumble_connection_t);
    }
    extern "C" {
        #[doc = " Called when disconnecting from a server."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection that has been terminated"]
        pub fn mumble_onServerDisconnected(connection: root::mumble_connection_t);
    }
    extern "C" {
        #[doc = " Called when the client has finished synchronizing with the server"]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection that has been terminated"]
        pub fn mumble_onServerSynchronized(connection: root::mumble_connection_t);
    }
    extern "C" {
        #[doc = " Called whenever any user on the server enters a channel"]
        #[doc = " This function will also be called when freshly connecting to a server as each user on that"]
        #[doc = " server needs to be \"added\" to the respective channel as far as the local client is concerned."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection this event is connected to"]
        #[doc = " @param userID The ID of the user this event has been triggered for"]
        #[doc = " @param previousChannelID The ID of the chanel the user is coming from. Negative IDs indicate that there is no previous channel (e.g. the user"]
        #[doc = " \tfreshly connected to the server) or the channel isn't available because of any other reason."]
        #[doc = " @param newChannelID The ID of the channel the user has entered. If the ID is negative, the new channel could not be retrieved. This means"]
        #[doc = " \tthat the ID is invalid."]
        pub fn mumble_onChannelEntered(
            connection: root::mumble_connection_t,
            userID: root::mumble_userid_t,
            previousChannelID: root::mumble_channelid_t,
            newChannelID: root::mumble_channelid_t,
        );
    }
    extern "C" {
        #[doc = " Called whenever a user leaves a channel."]
        #[doc = " This includes a client disconnecting from the server as this will also lead to the user not being in that channel anymore."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection this event is connected to"]
        #[doc = " @param userID The ID of the user that left the channel"]
        #[doc = " @param channelID The ID of the channel the user left. If the ID is negative, the channel could not be retrieved. This means that the ID is"]
        #[doc = " \tinvalid."]
        pub fn mumble_onChannelExited(
            connection: root::mumble_connection_t,
            userID: root::mumble_userid_t,
            channelID: root::mumble_channelid_t,
        );
    }
    extern "C" {
        #[doc = " Called when any user changes his/her talking state."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection this event is connected to"]
        #[doc = " @param userID The ID of the user whose talking state has been changed"]
        #[doc = " @param talkingState The new TalkingState the user has switched to."]
        pub fn mumble_onUserTalkingStateChanged(
            connection: root::mumble_connection_t,
            userID: root::mumble_userid_t,
            talkingState: root::talking_state_t,
        );
    }
    extern "C" {
        #[doc = " Called whenever there is audio input."]
        #[doc = ""]
        #[doc = " @param inputPCM A pointer to a short-array holding the pulse-code-modulation (PCM) representing the audio input. Its length"]
        #[doc = " \tis sampleCount * channelCount."]
        #[doc = " @param sampleCount The amount of sample points per channel"]
        #[doc = " @param channelCount The amount of channels in the audio"]
        #[doc = " @param isSpeech A boolean flag indicating whether Mumble considers the input as part of speech (instead of background noise)"]
        #[doc = " @returns Whether this callback has modified the audio input-array"]
        pub fn mumble_onAudioInput(
            inputPCM: *mut ::std::os::raw::c_short,
            sampleCount: u32,
            channelCount: u16,
            isSpeech: bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Called whenever Mumble fetches data from an active audio source (could be a voice packet or a playing sample)."]
        #[doc = " The provided audio buffer is the raw buffer without any processing applied to it yet."]
        #[doc = ""]
        #[doc = " @param outputPCM A pointer to a float-array holding the pulse-code-modulation (PCM) representing the audio output. Its length"]
        #[doc = " \tis sampleCount * channelCount."]
        #[doc = " @param sampleCount The amount of sample points per channel"]
        #[doc = " @param channelCount The amount of channels in the audio"]
        #[doc = " @param isSpeech Whether this audio belongs to a received voice packet (and will thus (most likely) contain speech)"]
        #[doc = " @param userID If isSpeech is true, this contains the ID of the user this voice packet belongs to. If isSpeech is false,"]
        #[doc = " \tthe content of this parameter is unspecified and should not be accessed"]
        #[doc = " @returns Whether this callback has modified the audio output-array"]
        pub fn mumble_onAudioSourceFetched(
            outputPCM: *mut f32,
            sampleCount: u32,
            channelCount: u16,
            isSpeech: bool,
            userID: root::mumble_userid_t,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Called whenever the fully mixed and processed audio is about to be handed to the audio backend (about to be played)."]
        #[doc = " Note that this happens immediately before Mumble clips the audio buffer."]
        #[doc = ""]
        #[doc = " @param outputPCM A pointer to a float-array holding the pulse-code-modulation (PCM) representing the audio output. Its length"]
        #[doc = " \tis sampleCount * channelCount."]
        #[doc = " @param sampleCount The amount of sample points per channel"]
        #[doc = " @param channelCount The amount of channels in the audio"]
        #[doc = " @returns Whether this callback has modified the audio output-array"]
        pub fn mumble_onAudioOutputAboutToPlay(
            outputPCM: *mut f32,
            sampleCount: u32,
            channelCount: u16,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Called whenever data has been received that has been sent by a plugin. This data should only be processed by the"]
        #[doc = " intended plugin. For this reason a dataID is provided that should be used to determine whether the data is intended"]
        #[doc = " for this plugin or not. As soon as the data has been processed, no further plugins will be notified about it."]
        #[doc = ""]
        #[doc = " @param connection The ID of the server-connection the data is coming from"]
        #[doc = " @param sender The ID of the user whose client's plugin has sent the data"]
        #[doc = " @param data The sent data represented as a string"]
        #[doc = " @param dataLength The length of data"]
        #[doc = " @param dataID The ID of this data"]
        #[doc = " @return Whether the given data has been processed by this plugin"]
        pub fn mumble_onReceiveData(
            connection: root::mumble_connection_t,
            sender: root::mumble_userid_t,
            data: *const ::std::os::raw::c_char,
            dataLength: usize,
            dataID: *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Called when a new user gets added to the user model. This is the case when that new user freshly connects to the server the"]
        #[doc = " local user is on but also when the local user connects to a server other clients are already connected to (in this case this"]
        #[doc = " method will be called for every client already on that server)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param userID The ID of the user that has been added"]
        pub fn mumble_onUserAdded(
            connection: root::mumble_connection_t,
            userID: root::mumble_userid_t,
        );
    }
    extern "C" {
        #[doc = " Called when a user gets removed from the user model. This is the case when that user disconnects from the server the"]
        #[doc = " local user is on but also when the local user disconnects from a server other clients are connected to (in this case this"]
        #[doc = " method will be called for every client on that server)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param userID The ID of the user that has been removed"]
        pub fn mumble_onUserRemoved(
            connection: root::mumble_connection_t,
            userID: root::mumble_userid_t,
        );
    }
    extern "C" {
        #[doc = " Called when a new channel gets added to the user model. This is the case when a new channel is created on the server the local"]
        #[doc = " user is on but also when the local user connects to a server that contains channels other than the root-channel (in this case"]
        #[doc = " this method will be called for ever non-root channel on that server)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param channelID The ID of the channel that has been added"]
        pub fn mumble_onChannelAdded(
            connection: root::mumble_connection_t,
            channelID: root::mumble_channelid_t,
        );
    }
    extern "C" {
        #[doc = " Called when a channel gets removed from the user model. This is the case when a channel is removed on the server the local"]
        #[doc = " user is on but also when the local user disconnects from a server that contains channels other than the root-channel (in this case"]
        #[doc = " this method will be called for ever non-root channel on that server)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param channelID The ID of the channel that has been removed"]
        pub fn mumble_onChannelRemoved(
            connection: root::mumble_connection_t,
            channelID: root::mumble_channelid_t,
        );
    }
    extern "C" {
        #[doc = " Called when a channel gets renamed. This also applies when a new channel is created (thus assigning it an initial name is also"]
        #[doc = " considered renaming)."]
        #[doc = ""]
        #[doc = " @param connection An object used to identify the current connection"]
        #[doc = " @param channelID The ID of the channel that has been renamed"]
        pub fn mumble_onChannelRenamed(
            connection: root::mumble_connection_t,
            channelID: root::mumble_channelid_t,
        );
    }
    extern "C" {
        #[doc = " Called when a key has been pressed or released while Mumble has keyboard focus."]
        #[doc = " Note that this callback will only work if the user has explicitly given permission to monitor keyboard"]
        #[doc = " events for this plugin. Thus if you want to use this callback, make sure your users know that they have to"]
        #[doc = " enable that."]
        #[doc = ""]
        #[doc = " @param keyCode The key code of the respective key. The character codes are defined"]
        #[doc = " \tvia the Mumble_KeyCode enum. For printable 7-bit ASCII characters these codes conform"]
        #[doc = " \tto the ASCII code-page with the only difference that case is not distinguished. Therefore"]
        #[doc = " \talways the upper-case letter code will be used for letters."]
        #[doc = " @param wasPres Whether the respective key has been pressed (instead of released)"]
        pub fn mumble_onKeyEvent(keyCode: u32, wasPress: bool);
    }
    extern "C" {
        #[doc = " This function is used to determine whether the plugin can find an update for itself that is available for download."]
        #[doc = ""]
        #[doc = " NOTE: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " @return Whether the plugin was able to find an update for itself"]
        pub fn mumble_hasUpdate() -> bool;
    }
    extern "C" {
        #[doc = " This function is used to retrieve the URL for downloading the newer/updated version of this plugin."]
        #[doc = " If the URL is too long for the provided buffer, it will have to be split up and be read chunk by chunk. Make sure"]
        #[doc = " though that you don't forget about the trailing null byte."]
        #[doc = ""]
        #[doc = " NOTE: This function may be called without the plugin being loaded"]
        #[doc = ""]
        #[doc = " @param buffer A pointer to the char buffer to write the UTF-8 encoded URL (as C-string) into"]
        #[doc = " @param bufferSize The size of the buffer"]
        #[doc = " @param offset The offset in the URL from which this functions should start writing it to the buffer"]
        #[doc = " @param Whether the URL has been completely written into the buffer yet. If this is false, this function will be called"]
        #[doc = " \tagain with a modified offset until the URL has been completely transferred."]
        pub fn mumble_getUpdateDownloadURL(
            buffer: *mut ::std::os::raw::c_char,
            bufferSize: u16,
            offset: u16,
        ) -> bool;
    }
}
